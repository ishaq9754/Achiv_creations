/**
 * Swiper 10.0.4
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2023 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: July 8, 2023
 */

var Swiper = function() {
    "use strict";
    function e(e) {
        return null !== e && "object" == typeof e && "constructor"in e && e.constructor === Object
    }
    function t(s, a) {
        void 0 === s && (s = {}),
        void 0 === a && (a = {}),
        Object.keys(a).forEach((i => {
            void 0 === s[i] ? s[i] = a[i] : e(a[i]) && e(s[i]) && Object.keys(a[i]).length > 0 && t(s[i], a[i])
        }
        ))
    }
    const s = {
        body: {},
        addEventListener() {},
        removeEventListener() {},
        activeElement: {
            blur() {},
            nodeName: ""
        },
        querySelector: () => null,
        querySelectorAll: () => [],
        getElementById: () => null,
        createEvent: () => ({
            initEvent() {}
        }),
        createElement: () => ({
            children: [],
            childNodes: [],
            style: {},
            setAttribute() {},
            getElementsByTagName: () => []
        }),
        createElementNS: () => ({}),
        importNode: () => null,
        location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
        }
    };
    function a() {
        const e = "undefined" != typeof document ? document : {};
        return t(e, s),
        e
    }
    const i = {
        document: s,
        navigator: {
            userAgent: ""
        },
        location: {
            hash: "",
            host: "",
            hostname: "",
            href: "",
            origin: "",
            pathname: "",
            protocol: "",
            search: ""
        },
        history: {
            replaceState() {},
            pushState() {},
            go() {},
            back() {}
        },
        CustomEvent: function() {
            return this
        },
        addEventListener() {},
        removeEventListener() {},
        getComputedStyle: () => ({
            getPropertyValue: () => ""
        }),
        Image() {},
        Date() {},
        screen: {},
        setTimeout() {},
        clearTimeout() {},
        matchMedia: () => ({}),
        requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(),
        null) : setTimeout(e, 0),
        cancelAnimationFrame(e) {
            "undefined" != typeof setTimeout && clearTimeout(e)
        }
    };
    function r() {
        const e = "undefined" != typeof window ? window : {};
        return t(e, i),
        e
    }
    function n(e, t) {
        return void 0 === t && (t = 0),
        setTimeout(e, t)
    }
    function l() {
        return Date.now()
    }
    function o(e, t) {
        void 0 === t && (t = "x");
        const s = r();
        let a, i, n;
        const l = function(e) {
            const t = r();
            let s;
            return t.getComputedStyle && (s = t.getComputedStyle(e, null)),
            !s && e.currentStyle && (s = e.currentStyle),
            s || (s = e.style),
            s
        }(e);
        return s.WebKitCSSMatrix ? (i = l.transform || l.webkitTransform,
        i.split(",").length > 6 && (i = i.split(", ").map((e => e.replace(",", "."))).join(", ")),
        n = new s.WebKitCSSMatrix("none" === i ? "" : i)) : (n = l.MozTransform || l.OTransform || l.MsTransform || l.msTransform || l.transform || l.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"),
        a = n.toString().split(",")),
        "x" === t && (i = s.WebKitCSSMatrix ? n.m41 : 16 === a.length ? parseFloat(a[12]) : parseFloat(a[4])),
        "y" === t && (i = s.WebKitCSSMatrix ? n.m42 : 16 === a.length ? parseFloat(a[13]) : parseFloat(a[5])),
        i || 0
    }
    function d(e) {
        return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1)
    }
    function c() {
        const e = Object(arguments.length <= 0 ? void 0 : arguments[0])
          , t = ["__proto__", "constructor", "prototype"];
        for (let a = 1; a < arguments.length; a += 1) {
            const i = a < 0 || arguments.length <= a ? void 0 : arguments[a];
            if (null != i && (s = i,
            !("undefined" != typeof window && void 0 !== window.HTMLElement ? s instanceof HTMLElement : s && (1 === s.nodeType || 11 === s.nodeType)))) {
                const s = Object.keys(Object(i)).filter((e => t.indexOf(e) < 0));
                for (let t = 0, a = s.length; t < a; t += 1) {
                    const a = s[t]
                      , r = Object.getOwnPropertyDescriptor(i, a);
                    void 0 !== r && r.enumerable && (d(e[a]) && d(i[a]) ? i[a].__swiper__ ? e[a] = i[a] : c(e[a], i[a]) : !d(e[a]) && d(i[a]) ? (e[a] = {},
                    i[a].__swiper__ ? e[a] = i[a] : c(e[a], i[a])) : e[a] = i[a])
                }
            }
        }
        var s;
        return e
    }
    function p(e, t, s) {
        e.style.setProperty(t, s)
    }
    function u(e) {
        let {swiper: t, targetPosition: s, side: a} = e;
        const i = r()
          , n = -t.translate;
        let l, o = null;
        const d = t.params.speed;
        t.wrapperEl.style.scrollSnapType = "none",
        i.cancelAnimationFrame(t.cssModeFrameID);
        const c = s > n ? "next" : "prev"
          , p = (e, t) => "next" === c && e >= t || "prev" === c && e <= t
          , u = () => {
            l = (new Date).getTime(),
            null === o && (o = l);
            const e = Math.max(Math.min((l - o) / d, 1), 0)
              , r = .5 - Math.cos(e * Math.PI) / 2;
            let c = n + r * (s - n);
            if (p(c, s) && (c = s),
            t.wrapperEl.scrollTo({
                [a]: c
            }),
            p(c, s))
                return t.wrapperEl.style.overflow = "hidden",
                t.wrapperEl.style.scrollSnapType = "",
                setTimeout(( () => {
                    t.wrapperEl.style.overflow = "",
                    t.wrapperEl.scrollTo({
                        [a]: c
                    })
                }
                )),
                void i.cancelAnimationFrame(t.cssModeFrameID);
            t.cssModeFrameID = i.requestAnimationFrame(u)
        }
        ;
        u()
    }
    function m(e) {
        return e.querySelector(".swiper-slide-transform") || e.shadowRoot && e.shadowRoot.querySelector(".swiper-slide-transform") || e
    }
    function h(e, t) {
        return void 0 === t && (t = ""),
        [...e.children].filter((e => e.matches(t)))
    }
    function f(e, t) {
        void 0 === t && (t = []);
        const s = document.createElement(e);
        return s.classList.add(...Array.isArray(t) ? t : [t]),
        s
    }
    function g(e) {
        const t = r()
          , s = a()
          , i = e.getBoundingClientRect()
          , n = s.body
          , l = e.clientTop || n.clientTop || 0
          , o = e.clientLeft || n.clientLeft || 0
          , d = e === t ? t.scrollY : e.scrollTop
          , c = e === t ? t.scrollX : e.scrollLeft;
        return {
            top: i.top + d - l,
            left: i.left + c - o
        }
    }
    function v(e, t) {
        return r().getComputedStyle(e, null).getPropertyValue(t)
    }
    function w(e) {
        let t, s = e;
        if (s) {
            for (t = 0; null !== (s = s.previousSibling); )
                1 === s.nodeType && (t += 1);
            return t
        }
    }
    function b(e, t) {
        const s = [];
        let a = e.parentElement;
        for (; a; )
            t ? a.matches(t) && s.push(a) : s.push(a),
            a = a.parentElement;
        return s
    }
    function y(e, t) {
        t && e.addEventListener("transitionend", (function s(a) {
            a.target === e && (t.call(e, a),
            e.removeEventListener("transitionend", s))
        }
        ))
    }
    function E(e, t, s) {
        const a = r();
        return s ? e["width" === t ? "offsetWidth" : "offsetHeight"] + parseFloat(a.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-right" : "margin-top")) + parseFloat(a.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-left" : "margin-bottom")) : e.offsetWidth
    }
    let x, S, T;
    function M() {
        return x || (x = function() {
            const e = r()
              , t = a();
            return {
                smoothScroll: t.documentElement && t.documentElement.style && "scrollBehavior"in t.documentElement.style,
                touch: !!("ontouchstart"in e || e.DocumentTouch && t instanceof e.DocumentTouch)
            }
        }()),
        x
    }
    function C(e) {
        return void 0 === e && (e = {}),
        S || (S = function(e) {
            let {userAgent: t} = void 0 === e ? {} : e;
            const s = M()
              , a = r()
              , i = a.navigator.platform
              , n = t || a.navigator.userAgent
              , l = {
                ios: !1,
                android: !1
            }
              , o = a.screen.width
              , d = a.screen.height
              , c = n.match(/(Android);?[\s\/]+([\d.]+)?/);
            let p = n.match(/(iPad).*OS\s([\d_]+)/);
            const u = n.match(/(iPod)(.*OS\s([\d_]+))?/)
              , m = !p && n.match(/(iPhone\sOS|iOS)\s([\d_]+)/)
              , h = "Win32" === i;
            let f = "MacIntel" === i;
            return !p && f && s.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${o}x${d}`) >= 0 && (p = n.match(/(Version)\/([\d.]+)/),
            p || (p = [0, 1, "13_0_0"]),
            f = !1),
            c && !h && (l.os = "android",
            l.android = !0),
            (p || m || u) && (l.os = "ios",
            l.ios = !0),
            l
        }(e)),
        S
    }
    function P() {
        return T || (T = function() {
            const e = r();
            let t = !1;
            function s() {
                const t = e.navigator.userAgent.toLowerCase();
                return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0
            }
            if (s()) {
                const s = String(e.navigator.userAgent);
                if (s.includes("Version/")) {
                    const [e,a] = s.split("Version/")[1].split(" ")[0].split(".").map((e => Number(e)));
                    t = e < 16 || 16 === e && a < 2
                }
            }
            return {
                isSafari: t || s(),
                needPerspectiveFix: t,
                isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent)
            }
        }()),
        T
    }
    var L = {
        on(e, t, s) {
            const a = this;
            if (!a.eventsListeners || a.destroyed)
                return a;
            if ("function" != typeof t)
                return a;
            const i = s ? "unshift" : "push";
            return e.split(" ").forEach((e => {
                a.eventsListeners[e] || (a.eventsListeners[e] = []),
                a.eventsListeners[e][i](t)
            }
            )),
            a
        },
        once(e, t, s) {
            const a = this;
            if (!a.eventsListeners || a.destroyed)
                return a;
            if ("function" != typeof t)
                return a;
            function i() {
                a.off(e, i),
                i.__emitterProxy && delete i.__emitterProxy;
                for (var s = arguments.length, r = new Array(s), n = 0; n < s; n++)
                    r[n] = arguments[n];
                t.apply(a, r)
            }
            return i.__emitterProxy = t,
            a.on(e, i, s)
        },
        onAny(e, t) {
            const s = this;
            if (!s.eventsListeners || s.destroyed)
                return s;
            if ("function" != typeof e)
                return s;
            const a = t ? "unshift" : "push";
            return s.eventsAnyListeners.indexOf(e) < 0 && s.eventsAnyListeners[a](e),
            s
        },
        offAny(e) {
            const t = this;
            if (!t.eventsListeners || t.destroyed)
                return t;
            if (!t.eventsAnyListeners)
                return t;
            const s = t.eventsAnyListeners.indexOf(e);
            return s >= 0 && t.eventsAnyListeners.splice(s, 1),
            t
        },
        off(e, t) {
            const s = this;
            return !s.eventsListeners || s.destroyed ? s : s.eventsListeners ? (e.split(" ").forEach((e => {
                void 0 === t ? s.eventsListeners[e] = [] : s.eventsListeners[e] && s.eventsListeners[e].forEach(( (a, i) => {
                    (a === t || a.__emitterProxy && a.__emitterProxy === t) && s.eventsListeners[e].splice(i, 1)
                }
                ))
            }
            )),
            s) : s
        },
        emit() {
            const e = this;
            if (!e.eventsListeners || e.destroyed)
                return e;
            if (!e.eventsListeners)
                return e;
            let t, s, a;
            for (var i = arguments.length, r = new Array(i), n = 0; n < i; n++)
                r[n] = arguments[n];
            "string" == typeof r[0] || Array.isArray(r[0]) ? (t = r[0],
            s = r.slice(1, r.length),
            a = e) : (t = r[0].events,
            s = r[0].data,
            a = r[0].context || e),
            s.unshift(a);
            return (Array.isArray(t) ? t : t.split(" ")).forEach((t => {
                e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach((e => {
                    e.apply(a, [t, ...s])
                }
                )),
                e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach((e => {
                    e.apply(a, s)
                }
                ))
            }
            )),
            e
        }
    };
    const z = (e, t) => {
        if (!e || e.destroyed || !e.params)
            return;
        const s = t.closest(e.isElement ? "swiper-slide" : `.${e.params.slideClass}`);
        if (s) {
            const t = s.querySelector(`.${e.params.lazyPreloaderClass}`);
            t && t.remove()
        }
    }
      , A = (e, t) => {
        if (!e.slides[t])
            return;
        const s = e.slides[t].querySelector('[loading="lazy"]');
        s && s.removeAttribute("loading")
    }
      , $ = e => {
        if (!e || e.destroyed || !e.params)
            return;
        let t = e.params.lazyPreloadPrevNext;
        const s = e.slides.length;
        if (!s || !t || t < 0)
            return;
        t = Math.min(t, s);
        const a = "auto" === e.params.slidesPerView ? e.slidesPerViewDynamic() : Math.ceil(e.params.slidesPerView)
          , i = e.activeIndex;
        if (e.params.grid && e.params.grid.rows > 1) {
            const s = i
              , r = [s - t];
            return r.push(...Array.from({
                length: t
            }).map(( (e, t) => s + a + t))),
            void e.slides.forEach(( (t, s) => {
                r.includes(t.column) && A(e, s)
            }
            ))
        }
        const r = i + a - 1;
        if (e.params.rewind || e.params.loop)
            for (let a = i - t; a <= r + t; a += 1) {
                const t = (a % s + s) % s;
                (t < i || t > r) && A(e, t)
            }
        else
            for (let a = Math.max(i - t, 0); a <= Math.min(r + t, s - 1); a += 1)
                a !== i && (a > r || a < i) && A(e, a)
    }
    ;
    var I = {
        updateSize: function() {
            const e = this;
            let t, s;
            const a = e.el;
            t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : a.clientWidth,
            s = void 0 !== e.params.height && null !== e.params.height ? e.params.height : a.clientHeight,
            0 === t && e.isHorizontal() || 0 === s && e.isVertical() || (t = t - parseInt(v(a, "padding-left") || 0, 10) - parseInt(v(a, "padding-right") || 0, 10),
            s = s - parseInt(v(a, "padding-top") || 0, 10) - parseInt(v(a, "padding-bottom") || 0, 10),
            Number.isNaN(t) && (t = 0),
            Number.isNaN(s) && (s = 0),
            Object.assign(e, {
                width: t,
                height: s,
                size: e.isHorizontal() ? t : s
            }))
        },
        updateSlides: function() {
            const e = this;
            function t(t) {
                return e.isHorizontal() ? t : {
                    width: "height",
                    "margin-top": "margin-left",
                    "margin-bottom ": "margin-right",
                    "margin-left": "margin-top",
                    "margin-right": "margin-bottom",
                    "padding-left": "padding-top",
                    "padding-right": "padding-bottom",
                    marginRight: "marginBottom"
                }[t]
            }
            function s(e, s) {
                return parseFloat(e.getPropertyValue(t(s)) || 0)
            }
            const a = e.params
              , {wrapperEl: i, slidesEl: r, size: n, rtlTranslate: l, wrongRTL: o} = e
              , d = e.virtual && a.virtual.enabled
              , c = d ? e.virtual.slides.length : e.slides.length
              , u = h(r, `.${e.params.slideClass}, swiper-slide`)
              , m = d ? e.virtual.slides.length : u.length;
            let f = [];
            const g = []
              , w = [];
            let b = a.slidesOffsetBefore;
            "function" == typeof b && (b = a.slidesOffsetBefore.call(e));
            let y = a.slidesOffsetAfter;
            "function" == typeof y && (y = a.slidesOffsetAfter.call(e));
            const x = e.snapGrid.length
              , S = e.slidesGrid.length;
            let T = a.spaceBetween
              , M = -b
              , C = 0
              , P = 0;
            if (void 0 === n)
                return;
            "string" == typeof T && T.indexOf("%") >= 0 ? T = parseFloat(T.replace("%", "")) / 100 * n : "string" == typeof T && (T = parseFloat(T)),
            e.virtualSize = -T,
            u.forEach((e => {
                l ? e.style.marginLeft = "" : e.style.marginRight = "",
                e.style.marginBottom = "",
                e.style.marginTop = ""
            }
            )),
            a.centeredSlides && a.cssMode && (p(i, "--swiper-centered-offset-before", ""),
            p(i, "--swiper-centered-offset-after", ""));
            const L = a.grid && a.grid.rows > 1 && e.grid;
            let z;
            L && e.grid.initSlides(m);
            const A = "auto" === a.slidesPerView && a.breakpoints && Object.keys(a.breakpoints).filter((e => void 0 !== a.breakpoints[e].slidesPerView)).length > 0;
            for (let i = 0; i < m; i += 1) {
                let r;
                if (z = 0,
                u[i] && (r = u[i]),
                L && e.grid.updateSlide(i, r, m, t),
                !u[i] || "none" !== v(r, "display")) {
                    if ("auto" === a.slidesPerView) {
                        A && (u[i].style[t("width")] = "");
                        const n = getComputedStyle(r)
                          , l = r.style.transform
                          , o = r.style.webkitTransform;
                        if (l && (r.style.transform = "none"),
                        o && (r.style.webkitTransform = "none"),
                        a.roundLengths)
                            z = e.isHorizontal() ? E(r, "width", !0) : E(r, "height", !0);
                        else {
                            const e = s(n, "width")
                              , t = s(n, "padding-left")
                              , a = s(n, "padding-right")
                              , i = s(n, "margin-left")
                              , l = s(n, "margin-right")
                              , o = n.getPropertyValue("box-sizing");
                            if (o && "border-box" === o)
                                z = e + i + l;
                            else {
                                const {clientWidth: s, offsetWidth: n} = r;
                                z = e + t + a + i + l + (n - s)
                            }
                        }
                        l && (r.style.transform = l),
                        o && (r.style.webkitTransform = o),
                        a.roundLengths && (z = Math.floor(z))
                    } else
                        z = (n - (a.slidesPerView - 1) * T) / a.slidesPerView,
                        a.roundLengths && (z = Math.floor(z)),
                        u[i] && (u[i].style[t("width")] = `${z}px`);
                    u[i] && (u[i].swiperSlideSize = z),
                    w.push(z),
                    a.centeredSlides ? (M = M + z / 2 + C / 2 + T,
                    0 === C && 0 !== i && (M = M - n / 2 - T),
                    0 === i && (M = M - n / 2 - T),
                    Math.abs(M) < .001 && (M = 0),
                    a.roundLengths && (M = Math.floor(M)),
                    P % a.slidesPerGroup == 0 && f.push(M),
                    g.push(M)) : (a.roundLengths && (M = Math.floor(M)),
                    (P - Math.min(e.params.slidesPerGroupSkip, P)) % e.params.slidesPerGroup == 0 && f.push(M),
                    g.push(M),
                    M = M + z + T),
                    e.virtualSize += z + T,
                    C = z,
                    P += 1
                }
            }
            if (e.virtualSize = Math.max(e.virtualSize, n) + y,
            l && o && ("slide" === a.effect || "coverflow" === a.effect) && (i.style.width = `${e.virtualSize + T}px`),
            a.setWrapperSize && (i.style[t("width")] = `${e.virtualSize + T}px`),
            L && e.grid.updateWrapperSize(z, f, t),
            !a.centeredSlides) {
                const t = [];
                for (let s = 0; s < f.length; s += 1) {
                    let i = f[s];
                    a.roundLengths && (i = Math.floor(i)),
                    f[s] <= e.virtualSize - n && t.push(i)
                }
                f = t,
                Math.floor(e.virtualSize - n) - Math.floor(f[f.length - 1]) > 1 && f.push(e.virtualSize - n)
            }
            if (d && a.loop) {
                const t = w[0] + T;
                if (a.slidesPerGroup > 1) {
                    const s = Math.ceil((e.virtual.slidesBefore + e.virtual.slidesAfter) / a.slidesPerGroup)
                      , i = t * a.slidesPerGroup;
                    for (let e = 0; e < s; e += 1)
                        f.push(f[f.length - 1] + i)
                }
                for (let s = 0; s < e.virtual.slidesBefore + e.virtual.slidesAfter; s += 1)
                    1 === a.slidesPerGroup && f.push(f[f.length - 1] + t),
                    g.push(g[g.length - 1] + t),
                    e.virtualSize += t
            }
            if (0 === f.length && (f = [0]),
            0 !== T) {
                const s = e.isHorizontal() && l ? "marginLeft" : t("marginRight");
                u.filter(( (e, t) => !(a.cssMode && !a.loop) || t !== u.length - 1)).forEach((e => {
                    e.style[s] = `${T}px`
                }
                ))
            }
            if (a.centeredSlides && a.centeredSlidesBounds) {
                let e = 0;
                w.forEach((t => {
                    e += t + (T || 0)
                }
                )),
                e -= T;
                const t = e - n;
                f = f.map((e => e <= 0 ? -b : e > t ? t + y : e))
            }
            if (a.centerInsufficientSlides) {
                let e = 0;
                if (w.forEach((t => {
                    e += t + (T || 0)
                }
                )),
                e -= T,
                e < n) {
                    const t = (n - e) / 2;
                    f.forEach(( (e, s) => {
                        f[s] = e - t
                    }
                    )),
                    g.forEach(( (e, s) => {
                        g[s] = e + t
                    }
                    ))
                }
            }
            if (Object.assign(e, {
                slides: u,
                snapGrid: f,
                slidesGrid: g,
                slidesSizesGrid: w
            }),
            a.centeredSlides && a.cssMode && !a.centeredSlidesBounds) {
                p(i, "--swiper-centered-offset-before", -f[0] + "px"),
                p(i, "--swiper-centered-offset-after", e.size / 2 - w[w.length - 1] / 2 + "px");
                const t = -e.snapGrid[0]
                  , s = -e.slidesGrid[0];
                e.snapGrid = e.snapGrid.map((e => e + t)),
                e.slidesGrid = e.slidesGrid.map((e => e + s))
            }
            if (m !== c && e.emit("slidesLengthChange"),
            f.length !== x && (e.params.watchOverflow && e.checkOverflow(),
            e.emit("snapGridLengthChange")),
            g.length !== S && e.emit("slidesGridLengthChange"),
            a.watchSlidesProgress && e.updateSlidesOffset(),
            !(d || a.cssMode || "slide" !== a.effect && "fade" !== a.effect)) {
                const t = `${a.containerModifierClass}backface-hidden`
                  , s = e.el.classList.contains(t);
                m <= a.maxBackfaceHiddenSlides ? s || e.el.classList.add(t) : s && e.el.classList.remove(t)
            }
        },
        updateAutoHeight: function(e) {
            const t = this
              , s = []
              , a = t.virtual && t.params.virtual.enabled;
            let i, r = 0;
            "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed);
            const n = e => a ? t.slides[t.getSlideIndexByData(e)] : t.slides[e];
            if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1)
                if (t.params.centeredSlides)
                    (t.visibleSlides || []).forEach((e => {
                        s.push(e)
                    }
                    ));
                else
                    for (i = 0; i < Math.ceil(t.params.slidesPerView); i += 1) {
                        const e = t.activeIndex + i;
                        if (e > t.slides.length && !a)
                            break;
                        s.push(n(e))
                    }
            else
                s.push(n(t.activeIndex));
            for (i = 0; i < s.length; i += 1)
                if (void 0 !== s[i]) {
                    const e = s[i].offsetHeight;
                    r = e > r ? e : r
                }
            (r || 0 === r) && (t.wrapperEl.style.height = `${r}px`)
        },
        updateSlidesOffset: function() {
            const e = this
              , t = e.slides
              , s = e.isElement ? e.isHorizontal() ? e.wrapperEl.offsetLeft : e.wrapperEl.offsetTop : 0;
            for (let a = 0; a < t.length; a += 1)
                t[a].swiperSlideOffset = (e.isHorizontal() ? t[a].offsetLeft : t[a].offsetTop) - s - e.cssOverflowAdjustment()
        },
        updateSlidesProgress: function(e) {
            void 0 === e && (e = this && this.translate || 0);
            const t = this
              , s = t.params
              , {slides: a, rtlTranslate: i, snapGrid: r} = t;
            if (0 === a.length)
                return;
            void 0 === a[0].swiperSlideOffset && t.updateSlidesOffset();
            let n = -e;
            i && (n = e),
            a.forEach((e => {
                e.classList.remove(s.slideVisibleClass)
            }
            )),
            t.visibleSlidesIndexes = [],
            t.visibleSlides = [];
            let l = s.spaceBetween;
            "string" == typeof l && l.indexOf("%") >= 0 ? l = parseFloat(l.replace("%", "")) / 100 * t.size : "string" == typeof l && (l = parseFloat(l));
            for (let e = 0; e < a.length; e += 1) {
                const o = a[e];
                let d = o.swiperSlideOffset;
                s.cssMode && s.centeredSlides && (d -= a[0].swiperSlideOffset);
                const c = (n + (s.centeredSlides ? t.minTranslate() : 0) - d) / (o.swiperSlideSize + l)
                  , p = (n - r[0] + (s.centeredSlides ? t.minTranslate() : 0) - d) / (o.swiperSlideSize + l)
                  , u = -(n - d)
                  , m = u + t.slidesSizesGrid[e];
                (u >= 0 && u < t.size - 1 || m > 1 && m <= t.size || u <= 0 && m >= t.size) && (t.visibleSlides.push(o),
                t.visibleSlidesIndexes.push(e),
                a[e].classList.add(s.slideVisibleClass)),
                o.progress = i ? -c : c,
                o.originalProgress = i ? -p : p
            }
        },
        updateProgress: function(e) {
            const t = this;
            if (void 0 === e) {
                const s = t.rtlTranslate ? -1 : 1;
                e = t && t.translate && t.translate * s || 0
            }
            const s = t.params
              , a = t.maxTranslate() - t.minTranslate();
            let {progress: i, isBeginning: r, isEnd: n, progressLoop: l} = t;
            const o = r
              , d = n;
            if (0 === a)
                i = 0,
                r = !0,
                n = !0;
            else {
                i = (e - t.minTranslate()) / a;
                const s = Math.abs(e - t.minTranslate()) < 1
                  , l = Math.abs(e - t.maxTranslate()) < 1;
                r = s || i <= 0,
                n = l || i >= 1,
                s && (i = 0),
                l && (i = 1)
            }
            if (s.loop) {
                const s = t.getSlideIndexByData(0)
                  , a = t.getSlideIndexByData(t.slides.length - 1)
                  , i = t.slidesGrid[s]
                  , r = t.slidesGrid[a]
                  , n = t.slidesGrid[t.slidesGrid.length - 1]
                  , o = Math.abs(e);
                l = o >= i ? (o - i) / n : (o + n - r) / n,
                l > 1 && (l -= 1)
            }
            Object.assign(t, {
                progress: i,
                progressLoop: l,
                isBeginning: r,
                isEnd: n
            }),
            (s.watchSlidesProgress || s.centeredSlides && s.autoHeight) && t.updateSlidesProgress(e),
            r && !o && t.emit("reachBeginning toEdge"),
            n && !d && t.emit("reachEnd toEdge"),
            (o && !r || d && !n) && t.emit("fromEdge"),
            t.emit("progress", i)
        },
        updateSlidesClasses: function() {
            const e = this
              , {slides: t, params: s, slidesEl: a, activeIndex: i} = e
              , r = e.virtual && s.virtual.enabled
              , n = e => h(a, `.${s.slideClass}${e}, swiper-slide${e}`)[0];
            let l;
            if (t.forEach((e => {
                e.classList.remove(s.slideActiveClass, s.slideNextClass, s.slidePrevClass)
            }
            )),
            r)
                if (s.loop) {
                    let t = i - e.virtual.slidesBefore;
                    t < 0 && (t = e.virtual.slides.length + t),
                    t >= e.virtual.slides.length && (t -= e.virtual.slides.length),
                    l = n(`[data-swiper-slide-index="${t}"]`)
                } else
                    l = n(`[data-swiper-slide-index="${i}"]`);
            else
                l = t[i];
            if (l) {
                l.classList.add(s.slideActiveClass);
                let e = function(e, t) {
                    const s = [];
                    for (; e.nextElementSibling; ) {
                        const a = e.nextElementSibling;
                        t ? a.matches(t) && s.push(a) : s.push(a),
                        e = a
                    }
                    return s
                }(l, `.${s.slideClass}, swiper-slide`)[0];
                s.loop && !e && (e = t[0]),
                e && e.classList.add(s.slideNextClass);
                let a = function(e, t) {
                    const s = [];
                    for (; e.previousElementSibling; ) {
                        const a = e.previousElementSibling;
                        t ? a.matches(t) && s.push(a) : s.push(a),
                        e = a
                    }
                    return s
                }(l, `.${s.slideClass}, swiper-slide`)[0];
                s.loop && 0 === !a && (a = t[t.length - 1]),
                a && a.classList.add(s.slidePrevClass)
            }
            e.emitSlidesClasses()
        },
        updateActiveIndex: function(e) {
            const t = this
              , s = t.rtlTranslate ? t.translate : -t.translate
              , {snapGrid: a, params: i, activeIndex: r, realIndex: n, snapIndex: l} = t;
            let o, d = e;
            const c = e => {
                let s = e - t.virtual.slidesBefore;
                return s < 0 && (s = t.virtual.slides.length + s),
                s >= t.virtual.slides.length && (s -= t.virtual.slides.length),
                s
            }
            ;
            if (void 0 === d && (d = function(e) {
                const {slidesGrid: t, params: s} = e
                  , a = e.rtlTranslate ? e.translate : -e.translate;
                let i;
                for (let e = 0; e < t.length; e += 1)
                    void 0 !== t[e + 1] ? a >= t[e] && a < t[e + 1] - (t[e + 1] - t[e]) / 2 ? i = e : a >= t[e] && a < t[e + 1] && (i = e + 1) : a >= t[e] && (i = e);
                return s.normalizeSlideIndex && (i < 0 || void 0 === i) && (i = 0),
                i
            }(t)),
            a.indexOf(s) >= 0)
                o = a.indexOf(s);
            else {
                const e = Math.min(i.slidesPerGroupSkip, d);
                o = e + Math.floor((d - e) / i.slidesPerGroup)
            }
            if (o >= a.length && (o = a.length - 1),
            d === r)
                return o !== l && (t.snapIndex = o,
                t.emit("snapIndexChange")),
                void (t.params.loop && t.virtual && t.params.virtual.enabled && (t.realIndex = c(d)));
            let p;
            p = t.virtual && i.virtual.enabled && i.loop ? c(d) : t.slides[d] ? parseInt(t.slides[d].getAttribute("data-swiper-slide-index") || d, 10) : d,
            Object.assign(t, {
                previousSnapIndex: l,
                snapIndex: o,
                previousRealIndex: n,
                realIndex: p,
                previousIndex: r,
                activeIndex: d
            }),
            t.initialized && $(t),
            t.emit("activeIndexChange"),
            t.emit("snapIndexChange"),
            n !== p && t.emit("realIndexChange"),
            (t.initialized || t.params.runCallbacksOnInit) && t.emit("slideChange")
        },
        updateClickedSlide: function(e) {
            const t = this
              , s = t.params
              , a = e.closest(`.${s.slideClass}, swiper-slide`);
            let i, r = !1;
            if (a)
                for (let e = 0; e < t.slides.length; e += 1)
                    if (t.slides[e] === a) {
                        r = !0,
                        i = e;
                        break
                    }
            if (!a || !r)
                return t.clickedSlide = void 0,
                void (t.clickedIndex = void 0);
            t.clickedSlide = a,
            t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(a.getAttribute("data-swiper-slide-index"), 10) : t.clickedIndex = i,
            s.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide()
        }
    };
    var k = {
        getTranslate: function(e) {
            void 0 === e && (e = this.isHorizontal() ? "x" : "y");
            const {params: t, rtlTranslate: s, translate: a, wrapperEl: i} = this;
            if (t.virtualTranslate)
                return s ? -a : a;
            if (t.cssMode)
                return a;
            let r = o(i, e);
            return r += this.cssOverflowAdjustment(),
            s && (r = -r),
            r || 0
        },
        setTranslate: function(e, t) {
            const s = this
              , {rtlTranslate: a, params: i, wrapperEl: r, progress: n} = s;
            let l, o = 0, d = 0;
            s.isHorizontal() ? o = a ? -e : e : d = e,
            i.roundLengths && (o = Math.floor(o),
            d = Math.floor(d)),
            s.previousTranslate = s.translate,
            s.translate = s.isHorizontal() ? o : d,
            i.cssMode ? r[s.isHorizontal() ? "scrollLeft" : "scrollTop"] = s.isHorizontal() ? -o : -d : i.virtualTranslate || (s.isHorizontal() ? o -= s.cssOverflowAdjustment() : d -= s.cssOverflowAdjustment(),
            r.style.transform = `translate3d(${o}px, ${d}px, 0px)`);
            const c = s.maxTranslate() - s.minTranslate();
            l = 0 === c ? 0 : (e - s.minTranslate()) / c,
            l !== n && s.updateProgress(e),
            s.emit("setTranslate", s.translate, t)
        },
        minTranslate: function() {
            return -this.snapGrid[0]
        },
        maxTranslate: function() {
            return -this.snapGrid[this.snapGrid.length - 1]
        },
      
    var D = 
        slideTo: function(e, t, s, a, i) {
            void 0 === e && (e = 0),
            void 0 === t && (t = this.params.speed),
            void 0 === s && (s = !0),
            "string" == typeof e && (e = parseInt(e, 10));
            const r = this;
            let n = e;
            n < 0 && (n = 0);
            const {params: l, snapGrid: o, slidesGrid: d, previousIndex: c, activeIndex: p, rtlTranslate: m, wrapperEl: h, enabled: f} = r;
            if (r.animating && l.preventInteractionOnTransition || !f && !a && !i)
                return !1;
            const g = Math.min(r.params.slidesPerGroupSkip, n);
            let v = g + Math.floor((n - g) / r.params.slidesPerGroup);
            v >= o.length && (v = o.length - 1);
            const w = -o[v];
            if (l.normalizeSlideIndex)
                for (let e = 0; e < d.length; e += 1) {
                    const t = -Math.floor(100 * w)
                      , s = Math.floor(100 * d[e])
                      , a = Math.floor(100 * d[e + 1]);
                    void 0 !== d[e + 1] ? t >= s && t < a - (a - s) / 2 ? n = e : t >= s && t < a && (n = e + 1) : t >= s && (n = e)
                }
            if (r.initialized && n !== p) {
                if (!r.allowSlideNext && (m ? w > r.translate && w > r.minTranslate() : w < r.translate && w < r.minTranslate()))
                    return !1;
                if (!r.allowSlidePrev && w > r.translate && w > r.maxTranslate() && (p || 0) !== n)
                    return !1
            }
            let b;
            if (n !== (c || 0) && s && r.emit("beforeSlideChangeStart"),
            r.updateProgress(w),
            b = n > p ? "next" : n < p ? "prev" : "reset",
            m && -w === r.translate || !m && w === r.translate)
                return r.updateActiveIndex(n),
                l.autoHeight && r.updateAutoHeight(),
                r.updateSlidesClasses(),
                "slide" !== l.effect && r.setTranslate(w),
                "reset" !== b && (r.transitionStart(s, b),
                r.transitionEnd(s, b)),
                !1;
            if (l.cssMode) {
                const e = r.isHorizontal()
                  , s = m ? w : -w;
                if (0 === t) {
                    const t = r.virtual && r.params.virtual.enabled;
                    t && (r.wrapperEl.style.scrollSnapType = "none",
                    r._immediateVirtual = !0),
                    t && !r._cssModeVirtualInitialSet && r.params.initialSlide > 0 ? (r._cssModeVirtualInitialSet = !0,
                    requestAnimationFrame(( () => {
                        h[e ? "scrollLeft" : "scrollTop"] = s
                    }
                    ))) : h[e ? "scrollLeft" : "scrollTop"] = s,
                    t && requestAnimationFrame(( () => {
                        r.wrapperEl.style.scrollSnapType = "",
                        r._immediateVirtual = !1
                    }
                    ))
                } else {
                    if (!r.support.smoothScroll)
                        return u({
                            swiper: r,
                            targetPosition: s,
                            side: e ? "left" : "top"
                        }),
                        !0;
                    h.scrollTo({
                        [e ? "left" : "top"]: s,
                        behavior: "smooth"
                    })
                }
                return !0
            }
            return r.setTransition(t),
            r.setTranslate(w),
            r.updateActiveIndex(n),
            r.updateSlidesClasses(),
            r.emit("beforeTransitionStart", t, a),
            r.transitionStart(s, b),
            0 === t ? r.transitionEnd(s, b) : r.animating || (r.animating = !0,
            r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function(e) {
                r && !r.destroyed && e.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd),
                r.onSlideToWrapperTransitionEnd = null,
                delete r.onSlideToWrapperTransitionEnd,
                r.transitionEnd(s, b))
            }
            ),
            r.wrapperEl.addEventListener("transitionend", r.onSlideToWrapperTransitionEnd)),
            !0
        },
        slideToLoop: function(e, t, s, a) {
            if (void 0 === e && (e = 0),
            void 0 === t && (t = this.params.speed),
            void 0 === s && (s = !0),
            "string" == typeof e) {
                e = parseInt(e, 10)
            }
            const i = this;
            let r = e;
            return i.params.loop && (i.virtual && i.params.virtual.enabled ? r += i.virtual.slidesBefore : r = i.getSlideIndexByData(r)),
            i.slideTo(r, t, s, a)
        },
       
    var G = {
        loopCreate: function(e) {
            const t = this
              , {params: s, slidesEl: a} = t;
            if (!s.loop || t.virtual && t.params.virtual.enabled)
                return;
            h(a, `.${s.slideClass}, swiper-slide`).forEach(( (e, t) => {
                e.setAttribute("data-swiper-slide-index", t)
            }
            )),
            t.loopFix({
                slideRealIndex: e,
                direction: s.centeredSlides ? void 0 : "next"
            })
        },
        loopFix: function(e) {
            let {slideRealIndex: t, slideTo: s=!0, direction: a, setTranslate: i, activeSlideIndex: r, byController: n, byMousewheel: l} = void 0 === e ? {} : e;
            const o = this;
            if (!o.params.loop)
                return;
            o.emit("beforeLoopFix");
            const {slides: d, allowSlidePrev: c, allowSlideNext: p, slidesEl: u, params: m} = o;
            if (o.allowSlidePrev = !0,
            o.allowSlideNext = !0,
            o.virtual && m.virtual.enabled)
                return s && (m.centeredSlides || 0 !== o.snapIndex ? m.centeredSlides && o.snapIndex < m.slidesPerView ? o.slideTo(o.virtual.slides.length + o.snapIndex, 0, !1, !0) : o.snapIndex === o.snapGrid.length - 1 && o.slideTo(o.virtual.slidesBefore, 0, !1, !0) : o.slideTo(o.virtual.slides.length, 0, !1, !0)),
                o.allowSlidePrev = c,
                o.allowSlideNext = p,
                void o.emit("loopFix");
            const h = "auto" === m.slidesPerView ? o.slidesPerViewDynamic() : Math.ceil(parseFloat(m.slidesPerView, 10));
            let f = m.loopedSlides || h;
            f % m.slidesPerGroup != 0 && (f += m.slidesPerGroup - f % m.slidesPerGroup),
            o.loopedSlides = f;
            const g = []
              , v = [];
            let w = o.activeIndex;
            void 0 === r ? r = o.getSlideIndex(o.slides.filter((e => e.classList.contains(m.slideActiveClass)))[0]) : w = r;
            const b = "next" === a || !a
              , y = "prev" === a || !a;
            let E = 0
              , x = 0;
            if (r < f) {
                E = Math.max(f - r, m.slidesPerGroup);
                for (let e = 0; e < f - r; e += 1) {
                    const t = e - Math.floor(e / d.length) * d.length;
                    g.push(d.length - t - 1)
                }
            } else if (r > o.slides.length - 2 * f) {
                x = Math.max(r - (o.slides.length - 2 * f), m.slidesPerGroup);
                for (let e = 0; e < x; e += 1) {
                    const t = e - Math.floor(e / d.length) * d.length;
                    v.push(t)
                }
            }
            if (y && g.forEach((e => {
                o.slides[e].swiperLoopMoveDOM = !0,
                u.prepend(o.slides[e]),
                o.slides[e].swiperLoopMoveDOM = !1
            }
            )),
            b && v.forEach((e => {
                o.slides[e].swiperLoopMoveDOM = !0,
                u.append(o.slides[e]),
                o.slides[e].swiperLoopMoveDOM = !1
            }
            )),
            o.recalcSlides(),
            "auto" === m.slidesPerView && o.updateSlides(),
            m.watchSlidesProgress && o.updateSlidesOffset(),
            s)
                if (g.length > 0 && y)
                    if (void 0 === t) {
                        const e = o.slidesGrid[w]
                          , t = o.slidesGrid[w + E] - e;
                        l ? o.setTranslate(o.translate - t) : (o.slideTo(w + E, 0, !1, !0),
                        i && (o.touches[o.isHorizontal() ? "startX" : "startY"] += t))
                    } else
                        i && o.slideToLoop(t, 0, !1, !0);
                else if (v.length > 0 && b)
                    if (void 0 === t) {
                        const e = o.slidesGrid[w]
                          , t = o.slidesGrid[w - x] - e;
                        l ? o.setTranslate(o.translate - t) : (o.slideTo(w - x, 0, !1, !0),
                        i && (o.touches[o.isHorizontal() ? "startX" : "startY"] += t))
                    } else
                        o.slideToLoop(t, 0, !1, !0);
            if (o.allowSlidePrev = c,
            o.allowSlideNext = p,
            o.controller && o.controller.control && !n) {
                const e = {
                    slideRealIndex: t,
                    slideTo: !1,
                    direction: a,
                    setTranslate: i,
                    activeSlideIndex: r,
                    byController: !0
                };
                Array.isArray(o.controller.control) ? o.controller.control.forEach((t => {
                    !t.destroyed && t.params.loop && t.loopFix(e)
                }
                )) : o.controller.control instanceof o.constructor && o.controller.control.params.loop && o.controller.control.loopFix(e)
            }
            o.emit("loopFix")
        },
        
    function B() {
        const e = this
          , {params: t, el: s} = e;
        if (s && 0 === s.offsetWidth)
            return;
        t.breakpoints && e.setBreakpoint();
        const {allowSlideNext: a, allowSlidePrev: i, snapGrid: r} = e
          , n = e.virtual && e.params.virtual.enabled;
        e.allowSlideNext = !0,
        e.allowSlidePrev = !0,
        e.updateSize(),
        e.updateSlides(),
        e.updateSlidesClasses();
        const l = n && t.loop;
        !("auto" === t.slidesPerView || t.slidesPerView > 1) || !e.isEnd || e.isBeginning || e.params.centeredSlides || l ? e.params.loop && !n ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0) : e.slideTo(e.slides.length - 1, 0, !1, !0),
        e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(e.autoplay.resizeTimeout),
        e.autoplay.resizeTimeout = setTimeout(( () => {
            e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.resume()
        }
        ), 500)),
        e.allowSlidePrev = i,
        e.allowSlideNext = a,
        e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow()
    }
    
    let F = !1;
    const V = (e, t) => {
        const s = a()
          , {params: i, el: r, wrapperEl: n, device: l} = e
          , o = !!i.nested
          , d = "on" === t ? "addEventListener" : "removeEventListener"
          , c = t;
        r[d]("pointerdown", e.onTouchStart, {
            passive: !1
        }),
        s[d]("pointermove", e.onTouchMove, {
            passive: !1,
            capture: o
        }),
        s[d]("pointerup", e.onTouchEnd, {
            passive: !0
        }),
        s[d]("pointercancel", e.onTouchEnd, {
            passive: !0
        }),
        s[d]("pointerout", e.onTouchEnd, {
            passive: !0
        }),
        s[d]("pointerleave", e.onTouchEnd, {
            passive: !0
        }),
        (i.preventClicks || i.preventClicksPropagation) && r[d]("click", e.onClick, !0),
        i.cssMode && n[d]("scroll", e.onScroll),
        i.updateOnWindowResize ? e[c](l.ios || l.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", B, !0) : e[c]("observerUpdate", B, !0),
        r[d]("load", e.onLoad, {
            capture: !0
        })
    }
    ;
    const j = (e, t) => e.grid && t.grid && t.grid.rows > 1;
    var W = {
        init: !0,
        direction: "horizontal",
        oneWayMovement: !1,
        touchEventsTarget: "wrapper",
        initialSlide: 0,
        speed: 300,
        cssMode: !1,
        updateOnWindowResize: !0,
        resizeObserver: !0,
        nested: !1,
        createElements: !1,
        enabled: !0,
        focusableElements: "input, select, option, textarea, button, video, label",
        width: null,
        height: null,
        preventInteractionOnTransition: !1,
        userAgent: null,
        url: null,
        edgeSwipeDetection: !1,
        edgeSwipeThreshold: 20,
        autoHeight: !1,
        setWrapperSize: !1,
        virtualTranslate: !1,
        effect: "slide",
        breakpoints: void 0,
        breakpointsBase: "window",
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerGroup: 1,
        slidesPerGroupSkip: 0,
        slidesPerGroupAuto: !1,
        centeredSlides: !1,
        centeredSlidesBounds: !1,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: !0,
        centerInsufficientSlides: !1,
        watchOverflow: !0,
        roundLengths: !1,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: !0,
        shortSwipes: !0,
        longSwipes: !0,
        longSwipesRatio: .5,
        longSwipesMs: 300,
        followFinger: !0,
        allowTouchMove: !0,
        threshold: 5,
        touchMoveStopPropagation: !1,
        touchStartPreventDefault: !0,
        touchStartForcePreventDefault: !1,
        touchReleaseOnEdges: !1,
        uniqueNavElements: !0,
        resistance: !0,
        resistanceRatio: .85,
        watchSlidesProgress: !1,
        grabCursor: !1,
        preventClicks: !0,
        preventClicksPropagation: !0,
        slideToClickedSlide: !1,
        loop: !1,
        loopedSlides: null,
        loopPreventsSliding: !0,
        rewind: !1,
        allowSlidePrev: !0,
        allowSlideNext: !0,
        swipeHandler: null,
        noSwiping: !0,
        noSwipingClass: "swiper-no-swiping",
        noSwipingSelector: null,
        passiveListeners: !0,
        maxBackfaceHiddenSlides: 10,
        containerModifierClass: "swiper-",
        slideClass: "swiper-slide",
        slideActiveClass: "swiper-slide-active",
        slideVisibleClass: "swiper-slide-visible",
        slideNextClass: "swiper-slide-next",
        slidePrevClass: "swiper-slide-prev",
        wrapperClass: "swiper-wrapper",
        lazyPreloaderClass: "swiper-lazy-preloader",
        lazyPreloadPrevNext: 0,
        runCallbacksOnInit: !0,
        _emitClasses: !1
    };
    function U(e, t) {
        return function(s) {
            void 0 === s && (s = {});
            const a = Object.keys(s)[0]
              , i = s[a];
            "object" == typeof i && null !== i ? (["navigation", "pagination", "scrollbar"].indexOf(a) >= 0 && !0 === e[a] && (e[a] = {
                auto: !0
            }),
            a in e && "enabled"in i ? (!0 === e[a] && (e[a] = {
                enabled: !0
            }),
            "object" != typeof e[a] || "enabled"in e[a] || (e[a].enabled = !0),
            e[a] || (e[a] = {
                enabled: !1
            }),
            c(t, s)) : c(t, s)) : c(t, s)
        }
    }
    const K = {
        eventsEmitter: L,
        update: I,
        translate: k,
        transition: {
            setTransition: function(e, t) {
                const s = this;
                s.params.cssMode || (s.wrapperEl.style.transitionDuration = `${e}ms`),
                s.emit("setTransition", e, t)
            },
           
        slide: D,
        loop: G,
        grabCursor: {
            setGrabCursor: function(e) {
                const t = this;
                if (!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode)
                    return;
                const s = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl;
                t.isElement && (t.__preventObserver__ = !0),
                s.style.cursor = "move",
                s.style.cursor = e ? "grabbing" : "grab",
                t.isElement && requestAnimationFrame(( () => {
                    t.__preventObserver__ = !1
                }
                ))
            },
            unsetGrabCursor: function() {
                const e = this;
                e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.isElement && (e.__preventObserver__ = !0),
                e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "",
                e.isElement && requestAnimationFrame(( () => {
                    e.__preventObserver__ = !1
                }
                )))
            }
        },
        events: {
            attachEvents: function() {
                const e = this
                  , t = a()
                  , {params: s} = e;
                e.onTouchStart = H.bind(e),
                e.onTouchMove = X.bind(e),
                e.onTouchEnd = Y.bind(e),
                s.cssMode && (e.onScroll = R.bind(e)),
                e.onClick = N.bind(e),
                e.onLoad = q.bind(e),
                F || (t.addEventListener("touchstart", _),
                F = !0),
                V(e, "on")
            },
            detachEvents: function() {
                V(this, "off")
            }
        },
        breakpoints: {
            setBreakpoint: function() {
                const e = this
                  , {realIndex: t, initialized: s, params: a, el: i} = e
                  , r = a.breakpoints;
                if (!r || r && 0 === Object.keys(r).length)
                    return;
                const n = e.getBreakpoint(r, e.params.breakpointsBase, e.el);
                if (!n || e.currentBreakpoint === n)
                    return;
                const l = (n in r ? r[n] : void 0) || e.originalParams
                  , o = j(e, a)
                  , d = j(e, l)
                  , p = a.enabled;
                o && !d ? (i.classList.remove(`${a.containerModifierClass}grid`, `${a.containerModifierClass}grid-column`),
                e.emitContainerClasses()) : !o && d && (i.classList.add(`${a.containerModifierClass}grid`),
                (l.grid.fill && "column" === l.grid.fill || !l.grid.fill && "column" === a.grid.fill) && i.classList.add(`${a.containerModifierClass}grid-column`),
                e.emitContainerClasses()),
                ["navigation", "pagination", "scrollbar"].forEach((t => {
                    if (void 0 === l[t])
                        return;
                    const s = a[t] && a[t].enabled
                      , i = l[t] && l[t].enabled;
                    s && !i && e[t].disable(),
                    !s && i && e[t].enable()
                }
                ));
                const u = l.direction && l.direction !== a.direction
                  , m = a.loop && (l.slidesPerView !== a.slidesPerView || u);
                u && s && e.changeDirection(),
                c(e.params, l);
                const h = e.params.enabled;
                Object.assign(e, {
                    allowTouchMove: e.params.allowTouchMove,
                    allowSlideNext: e.params.allowSlideNext,
                    allowSlidePrev: e.params.allowSlidePrev
                }),
                p && !h ? e.disable() : !p && h && e.enable(),
                e.currentBreakpoint = n,
                e.emit("_beforeBreakpoint", l),
                m && s && (e.loopDestroy(),
                e.loopCreate(t),
                e.updateSlides()),
                e.emit("breakpoint", l)
            },
            getBreakpoint: function(e, t, s) {
                if (void 0 === t && (t = "window"),
                !e || "container" === t && !s)
                    return;
                let a = !1;
                const i = r()
                  , n = "window" === t ? i.innerHeight : s.clientHeight
                  , l = Object.keys(e).map((e => {
                    if ("string" == typeof e && 0 === e.indexOf("@")) {
                        const t = parseFloat(e.substr(1));
                        return {
                            value: n * t,
                            point: e
                        }
                    }
                    return {
                        value: e,
                        point: e
                    }
                }
                ));
                l.sort(( (e, t) => parseInt(e.value, 10) - parseInt(t.value, 10)));
                for (let e = 0; e < l.length; e += 1) {
                    const {point: r, value: n} = l[e];
                    "window" === t ? i.matchMedia(`(min-width: ${n}px)`).matches && (a = r) : n <= s.clientWidth && (a = r)
                }
                return a || "max"
            }
        },
        checkOverflow: {
            checkOverflow: function() {
                const e = this
                  , {isLocked: t, params: s} = e
                  , {slidesOffsetBefore: a} = s;
                if (a) {
                    const t = e.slides.length - 1
                      , s = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * a;
                    e.isLocked = e.size > s
                } else
                    e.isLocked = 1 === e.snapGrid.length;
                !0 === s.allowSlideNext && (e.allowSlideNext = !e.isLocked),
                !0 === s.allowSlidePrev && (e.allowSlidePrev = !e.isLocked),
                t && t !== e.isLocked && (e.isEnd = !1),
                t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock")
            }
        },
        classes: {
            addClasses: function() {
                const e = this
                  , {classNames: t, params: s, rtl: a, el: i, device: r} = e
                  , n = function(e, t) {
                    const s = [];
                    return e.forEach((e => {
                        "object" == typeof e ? Object.keys(e).forEach((a => {
                            e[a] && s.push(t + a)
                        }
                        )) : "string" == typeof e && s.push(t + e)
                    }
                    )),
                    s
                }(["initialized", s.direction, {
                    "free-mode": e.params.freeMode && s.freeMode.enabled
                }, {
                    autoheight: s.autoHeight
                }, {
                    rtl: a
                }, {
                    grid: s.grid && s.grid.rows > 1
                }, {
                    "grid-column": s.grid && s.grid.rows > 1 && "column" === s.grid.fill
                }, {
                    android: r.android
                }, {
                    ios: r.ios
                }, {
                    "css-mode": s.cssMode
                }, {
                    centered: s.cssMode && s.centeredSlides
                }, {
                    "watch-progress": s.watchSlidesProgress
                }], s.containerModifierClass);
                t.push(...n),
                i.classList.add(...t),
                e.emitContainerClasses()
            },
            removeClasses: function() {
                const {el: e, classNames: t} = this;
                e.classList.remove(...t),
                this.emitContainerClasses()
            }
        }
    }
      , Z = {};
    class Q {
        constructor() {
            let e, t;
            for (var s = arguments.length, i = new Array(s), r = 0; r < s; r++)
                i[r] = arguments[r];
            1 === i.length && i[0].constructor && "Object" === Object.prototype.toString.call(i[0]).slice(8, -1) ? t = i[0] : [e,t] = i,
            t || (t = {}),
            t = c({}, t),
            e && !t.el && (t.el = e);
            const n = a();
            if (t.el && "string" == typeof t.el && n.querySelectorAll(t.el).length > 1) {
                const e = [];
                return n.querySelectorAll(t.el).forEach((s => {
                    const a = c({}, t, {
                        el: s
                    });
                    e.push(new Q(a))
                }
                )),
                e
            }
            const l = this;
            l.__swiper__ = !0,
            l.support = M(),
            l.device = C({
                userAgent: t.userAgent
            }),
            l.browser = P(),
            l.eventsListeners = {},
            l.eventsAnyListeners = [],
            l.modules = [...l.__modules__],
            t.modules && Array.isArray(t.modules) && l.modules.push(...t.modules);
            const o = {};
            l.modules.forEach((e => {
                e({
                    params: t,
                    swiper: l,
                    extendParams: U(t, o),
                    on: l.on.bind(l),
                    once: l.once.bind(l),
                    off: l.off.bind(l),
                    emit: l.emit.bind(l)
                })
            }
            ));
            const d = c({}, W, o);
            return l.params = c({}, d, Z, t),
            l.originalParams = c({}, l.params),
            l.passedParams = c({}, t),
            l.params && l.params.on && Object.keys(l.params.on).forEach((e => {
                l.on(e, l.params.on[e])
            }
            )),
            l.params && l.params.onAny && l.onAny(l.params.onAny),
            Object.assign(l, {
                enabled: l.params.enabled,
                el: e,
                classNames: [],
                slides: [],
                slidesGrid: [],
                snapGrid: [],
                slidesSizesGrid: [],
                isHorizontal: () => "horizontal" === l.params.direction,
                isVertical: () => "vertical" === l.params.direction,
                activeIndex: 0,
                realIndex: 0,
                isBeginning: !0,
                isEnd: !1,
                translate: 0,
                previousTranslate: 0,
                progress: 0,
                velocity: 0,
                animating: !1,
                cssOverflowAdjustment() {
                    return Math.trunc(this.translate / 2 ** 23) * 2 ** 23
                },
                allowSlideNext: l.params.allowSlideNext,
                allowSlidePrev: l.params.allowSlidePrev,
                touchEventsData: {
                    isTouched: void 0,
                    isMoved: void 0,
                    allowTouchCallbacks: void 0,
                    touchStartTime: void 0,
                    isScrolling: void 0,
                    currentTranslate: void 0,
                    startTranslate: void 0,
                    allowThresholdMove: void 0,
                    focusableElements: l.params.focusableElements,
                    lastClickTime: 0,
                    clickTimeout: void 0,
                    velocities: [],
                    allowMomentumBounce: void 0,
                    startMoving: void 0,
                    evCache: []
                },
                allowClick: !0,
                allowTouchMove: l.params.allowTouchMove,
                touches: {
                    startX: 0,
                    startY: 0,
                    currentX: 0,
                    currentY: 0,
                    diff: 0
                },
                imagesToLoad: [],
                imagesLoaded: 0
            }),
            l.emit("_swiper"),
            l.params.init && l.init(),
            l
        }
        getSlideIndex(e) {
            const {slidesEl: t, params: s} = this
              , a = w(h(t, `.${s.slideClass}, swiper-slide`)[0]);
            return w(e) - a
        }
        getSlideIndexByData(e) {
            return this.getSlideIndex(this.slides.filter((t => 1 * t.getAttribute("data-swiper-slide-index") === e))[0])
        }
        recalcSlides() {
            const {slidesEl: e, params: t} = this;
            this.slides = h(e, `.${t.slideClass}, swiper-slide`)
        }
      
        emitContainerClasses() {
            const e = this;
            if (!e.params._emitClasses || !e.el)
                return;
            const t = e.el.className.split(" ").filter((t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass)));
            e.emit("_containerClasses", t.join(" "))
        }
        getSlideClasses(e) {
            const t = this;
            return t.destroyed ? "" : e.className.split(" ").filter((e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ")
        }
        emitSlidesClasses() {
            const e = this;
            if (!e.params._emitClasses || !e.el)
                return;
            const t = [];
            e.slides.forEach((s => {
                const a = e.getSlideClasses(s);
                t.push({
                    slideEl: s,
                    classNames: a
                }),
                e.emit("_slideClass", s, a)
            }
            )),
            e.emit("_slideClasses", t)
        }
       
        mount(e) {
            const t = this;
            if (t.mounted)
                return !0;
            let s = e || t.params.el;
            if ("string" == typeof s && (s = document.querySelector(s)),
            !s)
                return !1;
            s.swiper = t,
            s.parentNode && s.parentNode.host && (t.isElement = !0);
            const a = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`;
            let i = ( () => {
                if (s && s.shadowRoot && s.shadowRoot.querySelector) {
                    return s.shadowRoot.querySelector(a())
                }
                return h(s, a())[0]
            }
            )();
            return !i && t.params.createElements && (i = f("div", t.params.wrapperClass),
            s.append(i),
            h(s, `.${t.params.slideClass}`).forEach((e => {
                i.append(e)
            }
            ))),
            Object.assign(t, {
                el: s,
                wrapperEl: i,
                slidesEl: t.isElement ? s.parentNode.host : i,
                hostEl: t.isElement ? s.parentNode.host : s,
                mounted: !0,
                rtl: "rtl" === s.dir.toLowerCase() || "rtl" === v(s, "direction"),
                rtlTranslate: "horizontal" === t.params.direction && ("rtl" === s.dir.toLowerCase() || "rtl" === v(s, "direction")),
                wrongRTL: "-webkit-box" === v(i, "display")
            }),
            !0
        }
        init(e) {
            const t = this;
            if (t.initialized)
                return t;
            return !1 === t.mount(e) || (t.emit("beforeInit"),
            t.params.breakpoints && t.setBreakpoint(),
            t.addClasses(),
            t.updateSize(),
            t.updateSlides(),
            t.params.watchOverflow && t.checkOverflow(),
            t.params.grabCursor && t.enabled && t.setGrabCursor(),
            t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0),
            t.params.loop && t.loopCreate(),
            t.attachEvents(),
            [...t.el.querySelectorAll('[loading="lazy"]')].forEach((e => {
                e.complete ? z(t, e) : e.addEventListener("load", (e => {
                    z(t, e.target)
                }
                ))
            }
            )),
            $(t),
            t.initialized = !0,
            $(t),
            t.emit("init"),
            t.emit("afterInit")),
            t
        }
      
        static extendDefaults(e) {
            c(Z, e)
        }
        static get extendedDefaults() {
            return Z
        }
        static get defaults() {
            return W
        }
        static installModule(e) {
            Q.prototype.__modules__ || (Q.prototype.__modules__ = []);
            const t = Q.prototype.__modules__;
            "function" == typeof e && t.indexOf(e) < 0 && t.push(e)
        }
        static use(e) {
            return Array.isArray(e) ? (e.forEach((e => Q.installModule(e))),
            Q) : (Q.installModule(e),
            Q)
        }
    }
    function J(e, t, s, a) {
        return e.params.createElements && Object.keys(a).forEach((i => {
            if (!s[i] && !0 === s.auto) {
                let r = h(e.el, `.${a[i]}`)[0];
                r || (r = f("div", a[i]),
                r.className = a[i],
                e.el.append(r)),
                s[i] = r,
                t[i] = r
            }
        }
        )),
        s
    }
    function ee(e) {
        return void 0 === e && (e = ""),
        `.${e.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}`
    }
    
    function ne(e) {
        const {effect: t, swiper: s, on: a, setTranslate: i, setTransition: r, overwriteParams: n, perspective: l, recreateShadows: o, getEffectParams: d} = e;
        let c;
        a("beforeInit", ( () => {
            if (s.params.effect !== t)
                return;
            s.classNames.push(`${s.params.containerModifierClass}${t}`),
            l && l() && s.classNames.push(`${s.params.containerModifierClass}3d`);
            const e = n ? n() : {};
            Object.assign(s.params, e),
            Object.assign(s.originalParams, e)
        }
        )),
        a("setTranslate", ( () => {
            s.params.effect === t && i()
        }
        )),
        a("setTransition", ( (e, a) => {
            s.params.effect === t && r(a)
        }
        )),
    
    }
   
    Object.keys(K).forEach((e => {
        Object.keys(K[e]).forEach((t => {
            Q.prototype[t] = K[e][t]
        }
        ))
    }
    )),
    Q.use([function(e) {
        let {swiper: t, on: s, emit: a} = e;
        const i = r();
        let n = null
          , l = null;
        const o = () => {
            t && !t.destroyed && t.initialized && (a("beforeResize"),
            a("resize"))
        }
          , d = () => {
            t && !t.destroyed && t.initialized && a("orientationchange")
        }
        ;
        s("init", ( () => {
            t.params.resizeObserver && void 0 !== i.ResizeObserver ? t && !t.destroyed && t.initialized && (n = new ResizeObserver((e => {
                l = i.requestAnimationFrame(( () => {
                    const {width: s, height: a} = t;
                    let i = s
                      , r = a;
                    e.forEach((e => {
                        let {contentBoxSize: s, contentRect: a, target: n} = e;
                        n && n !== t.el || (i = a ? a.width : (s[0] || s).inlineSize,
                        r = a ? a.height : (s[0] || s).blockSize)
                    }
                    )),
                    i === s && r === a || o()
                }
                ))
            }
            )),
            n.observe(t.el)) : (i.addEventListener("resize", o),
            i.addEventListener("orientationchange", d))
        }
        )),
        s("destroy", ( () => {
            l && i.cancelAnimationFrame(l),
            n && n.unobserve && t.el && (n.unobserve(t.el),
            n = null),
            i.removeEventListener("resize", o),
            i.removeEventListener("orientationchange", d)
        }
        ))
    }
    , function(e) {
        let {swiper: t, extendParams: s, on: a, emit: i} = e;
        const n = []
          , l = r()
          , o = function(e, s) {
            void 0 === s && (s = {});
            const a = new (l.MutationObserver || l.WebkitMutationObserver)((e => {
                if (t.__preventObserver__)
                    return;
                if (1 === e.length)
                    return void i("observerUpdate", e[0]);
                const s = function() {
                    i("observerUpdate", e[0])
                };
                l.requestAnimationFrame ? l.requestAnimationFrame(s) : l.setTimeout(s, 0)
            }
            ));
            a.observe(e, {
                attributes: void 0 === s.attributes || s.attributes,
                childList: void 0 === s.childList || s.childList,
                characterData: void 0 === s.characterData || s.characterData
            }),
            n.push(a)
        };
        s({
            observer: !1,
            observeParents: !1,
            observeSlideChildren: !1
        }),
        a("init", ( () => {
            if (t.params.observer) {
                if (t.params.observeParents) {
                    const e = b(t.el);
                    for (let t = 0; t < e.length; t += 1)
                        o(e[t])
                }
                o(t.el, {
                    childList: t.params.observeSlideChildren
                }),
                o(t.wrapperEl, {
                    attributes: !1
                })
            }
        }
        )),
        a("destroy", ( () => {
            n.forEach((e => {
                e.disconnect()
            }
            )),
            n.splice(0, n.length)
        }
        ))
    }
    ]);
    const ce = [function(e) {
        let t, {swiper: s, extendParams: i, on: r, emit: n} = e;
        i({
            virtual: {
                enabled: !1,
                slides: [],
                cache: !0,
                renderSlide: null,
                renderExternal: null,
                renderExternalUpdate: !0,
                addSlidesBefore: 0,
                addSlidesAfter: 0
            }
        });
        const l = a();
        s.virtual = {
            cache: {},
            from: void 0,
            to: void 0,
            slides: [],
            offset: 0,
            slidesGrid: []
        };
       
        r("beforeInit", ( () => {
            if (!s.params.virtual.enabled)
                return;
            let e;
            if (void 0 === s.passedParams.virtual.slides) {
                const t = [...s.slidesEl.children].filter((e => e.matches(`.${s.params.slideClass}, swiper-slide`)));
                t && t.length && (s.virtual.slides = [...t],
                e = !0,
                t.forEach(( (e, t) => {
                    e.setAttribute("data-swiper-slide-index", t),
                    s.virtual.cache[t] = e,
                    e.remove()
                }
                )))
            }
            e || (s.virtual.slides = s.params.virtual.slides),
            s.classNames.push(`${s.params.containerModifierClass}virtual`),
            s.params.watchSlidesProgress = !0,
            s.originalParams.watchSlidesProgress = !0,
            s.params.initialSlide || c()
        }
        )),
        r("setTranslate", ( () => {
            s.params.virtual.enabled && (s.params.cssMode && !s._immediateVirtual ? (clearTimeout(t),
            t = setTimeout(( () => {
                c()
            }
            ), 100)) : c())
        }
        )),
        r("init update resize", ( () => {
            s.params.virtual.enabled && s.params.cssMode && p(s.wrapperEl, "--swiper-virtual-size", `${s.virtualSize}px`)
        }
        )),
        Object.assign(s.virtual, {
            appendSlide: function(e) {
                if ("object" == typeof e && "length"in e)
                    for (let t = 0; t < e.length; t += 1)
                        e[t] && s.virtual.slides.push(e[t]);
                else
                    s.virtual.slides.push(e);
                c(!0)
            },
            prependSlide: function(e) {
                const t = s.activeIndex;
                let a = t + 1
                  , i = 1;
                if (Array.isArray(e)) {
                    for (let t = 0; t < e.length; t += 1)
                        e[t] && s.virtual.slides.unshift(e[t]);
                    a = t + e.length,
                    i = e.length
                } else
                    s.virtual.slides.unshift(e);
                if (s.params.virtual.cache) {
                    const e = s.virtual.cache
                      , t = {};
                    Object.keys(e).forEach((s => {
                        const a = e[s]
                          , r = a.getAttribute("data-swiper-slide-index");
                        r && a.setAttribute("data-swiper-slide-index", parseInt(r, 10) + i),
                        t[parseInt(s, 10) + i] = a
                    }
                    )),
                    s.virtual.cache = t
                }
                c(!0),
                s.slideTo(a, 0)
            },
            removeSlide: function(e) {
                if (null == e)
                    return;
                let t = s.activeIndex;
                if (Array.isArray(e))
                    for (let a = e.length - 1; a >= 0; a -= 1)
                        s.virtual.slides.splice(e[a], 1),
                        s.params.virtual.cache && delete s.virtual.cache[e[a]],
                        e[a] < t && (t -= 1),
                        t = Math.max(t, 0);
                else
                    s.virtual.slides.splice(e, 1),
                    s.params.virtual.cache && delete s.virtual.cache[e],
                    e < t && (t -= 1),
                    t = Math.max(t, 0);
                c(!0),
                s.slideTo(t, 0)
            },
            removeAllSlides: function() {
                s.virtual.slides = [],
                s.params.virtual.cache && (s.virtual.cache = {}),
                c(!0),
                s.slideTo(0, 0)
            },
            update: c
        })
    }
    , function(e) {
        let {swiper: t, extendParams: s, on: i, emit: n} = e;
        const l = a()
          , o = r();
       
        t.keyboard = {
            enabled: !1
        },
        s({
            keyboard: {
                enabled: !1,
                onlyInViewport: !0,
                pageUpDown: !0
            }
        }),
        i("init", ( () => {
            t.params.keyboard.enabled && c()
        }
        )),
        i("destroy", ( () => {
            t.keyboard.enabled && p()
        }
        )),
        Object.assign(t.keyboard, {
            enable: c,
            disable: p
        })
    }
    , function(e) {
        let {swiper: t, extendParams: s, on: a, emit: i} = e;
        const o = r();
        let d;
        s({
            mousewheel: {
                enabled: !1,
                releaseOnEdges: !1,
                invert: !1,
                forceToAxis: !1,
                sensitivity: 1,
                eventsTarget: "container",
                thresholdDelta: null,
                thresholdTime: null,
                noMousewheelClass: "swiper-no-mousewheel"
            }
        }),
        t.mousewheel = {
            enabled: !1
        };
        a("init", ( () => {
            !t.params.mousewheel.enabled && t.params.cssMode && b(),
            t.params.mousewheel.enabled && w()
        }
        )),
        a("destroy", ( () => {
            t.params.cssMode && w(),
            t.mousewheel.enabled && b()
        }
        )),
        Object.assign(t.mousewheel, {
            enable: w,
            disable: b
        })
    }
    , function(e) {
        let {swiper: t, extendParams: s, on: a, emit: i} = e;
        s({
            navigation: {
                nextEl: null,
                prevEl: null,
                hideOnClick: !1,
                disabledClass: "swiper-button-disabled",
                hiddenClass: "swiper-button-hidden",
                lockClass: "swiper-button-lock",
                navigationDisabledClass: "swiper-navigation-disabled"
            }
        }),
        t.navigation = {
            nextEl: null,
            prevEl: null
        };
        const r = e => (Array.isArray(e) || (e = [e].filter((e => !!e))),
        e);
        function n(e) {
            let s;
            return e && "string" == typeof e && t.isElement && (s = t.el.querySelector(e),
            s) ? s : (e && ("string" == typeof e && (s = [...document.querySelectorAll(e)]),
            t.params.uniqueNavElements && "string" == typeof e && s.length > 1 && 1 === t.el.querySelectorAll(e).length && (s = t.el.querySelector(e))),
            e && !s ? e : s)
        }
        function l(e, s) {
            const a = t.params.navigation;
            (e = r(e)).forEach((e => {
                e && (e.classList[s ? "add" : "remove"](...a.disabledClass.split(" ")),
                "BUTTON" === e.tagName && (e.disabled = s),
                t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](a.lockClass))
            }
            ))
        }
        function o() {
            const {nextEl: e, prevEl: s} = t.navigation;
            if (t.params.loop)
                return l(s, !1),
                void l(e, !1);
            l(s, t.isBeginning && !t.params.rewind),
            l(e, t.isEnd && !t.params.rewind)
        }
        function d(e) {
            e.preventDefault(),
            (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(),
            i("navigationPrev"))
        }
        function c(e) {
            e.preventDefault(),
            (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(),
            i("navigationNext"))
        }
        function p() {
            const e = t.params.navigation;
            if (t.params.navigation = J(t, t.originalParams.navigation, t.params.navigation, {
                nextEl: "swiper-button-next",
                prevEl: "swiper-button-prev"
            }),
            !e.nextEl && !e.prevEl)
                return;
            let s = n(e.nextEl)
              , a = n(e.prevEl);
            Object.assign(t.navigation, {
                nextEl: s,
                prevEl: a
            }),
            s = r(s),
            a = r(a);
            const i = (s, a) => {
                s && s.addEventListener("click", "next" === a ? c : d),
                !t.enabled && s && s.classList.add(...e.lockClass.split(" "))
            }
            ;
            s.forEach((e => i(e, "next"))),
            a.forEach((e => i(e, "prev")))
        }
        function u() {
            let {nextEl: e, prevEl: s} = t.navigation;
            e = r(e),
            s = r(s);
            const a = (e, s) => {
                e.removeEventListener("click", "next" === s ? c : d),
                e.classList.remove(...t.params.navigation.disabledClass.split(" "))
            }
            ;
            e.forEach((e => a(e, "next"))),
            s.forEach((e => a(e, "prev")))
        }
        a("init", ( () => {
            !1 === t.params.navigation.enabled ? m() : (p(),
            o())
        }
        )),
        a("toEdge fromEdge lock unlock", ( () => {
            o()
        }
        )),
        a("destroy", ( () => {
            u()
        }
        )),
        a("enable disable", ( () => {
            let {nextEl: e, prevEl: s} = t.navigation;
            e = r(e),
            s = r(s),
            [...e, ...s].filter((e => !!e)).forEach((e => e.classList[t.enabled ? "remove" : "add"](t.params.navigation.lockClass)))
        }
        )),
        a("click", ( (e, s) => {
            let {nextEl: a, prevEl: n} = t.navigation;
            a = r(a),
            n = r(n);
            const l = s.target;
            if (t.params.navigation.hideOnClick && !n.includes(l) && !a.includes(l)) {
                if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === l || t.pagination.el.contains(l)))
                    return;
                let e;
                a.length ? e = a[0].classList.contains(t.params.navigation.hiddenClass) : n.length && (e = n[0].classList.contains(t.params.navigation.hiddenClass)),
                i(!0 === e ? "navigationShow" : "navigationHide"),
                [...a, ...n].filter((e => !!e)).forEach((e => e.classList.toggle(t.params.navigation.hiddenClass)))
            }
        }
        ));
        const m = () => {
            t.el.classList.add(...t.params.navigation.navigationDisabledClass.split(" ")),
            u()
        }
        ;
        Object.assign(t.navigation, {
            enable: () => {
                t.el.classList.remove(...t.params.navigation.navigationDisabledClass.split(" ")),
                p(),
                o()
            }
            ,
            disable: m,
            update: o,
            init: p,
            destroy: u
        })
    }
    , function(e) {
        let {swiper: t, extendParams: s, on: a, emit: i} = e;
        const r = "swiper-pagination";
        let n;
        s({
            pagination: {
                el: null,
                bulletElement: "span",
                clickable: !1,
                hideOnClick: !1,
                renderBullet: null,
                renderProgressbar: null,
                renderFraction: null,
                renderCustom: null,
                progressbarOpposite: !1,
                type: "bullets",
                dynamicBullets: !1,
                dynamicMainBullets: 1,
                formatFractionCurrent: e => e,
                formatFractionTotal: e => e,
                bulletClass: `${r}-bullet`,
                bulletActiveClass: `${r}-bullet-active`,
                modifierClass: `${r}-`,
                currentClass: `${r}-current`,
                totalClass: `${r}-total`,
                hiddenClass: `${r}-hidden`,
                progressbarFillClass: `${r}-progressbar-fill`,
                progressbarOppositeClass: `${r}-progressbar-opposite`,
                clickableClass: `${r}-clickable`,
                lockClass: `${r}-lock`,
                horizontalClass: `${r}-horizontal`,
                verticalClass: `${r}-vertical`,
                paginationDisabledClass: `${r}-disabled`
            }
        }),
        t.pagination = {
            el: null,
            bullets: []
        };
        let l = 0;
        const o = e => (Array.isArray(e) || (e = [e].filter((e => !!e))),
        e);
        function d() {
            return !t.params.pagination.el || !t.pagination.el || Array.isArray(t.pagination.el) && 0 === t.pagination.el.length
        }
       
        function u() {
            const e = t.rtl
              , s = t.params.pagination;
            if (d())
                return;
            let a, r, p = t.pagination.el;
            p = o(p);
            const u = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length
              , m = t.params.loop ? Math.ceil(u / t.params.slidesPerGroup) : t.snapGrid.length;
            if (t.params.loop ? (r = t.previousRealIndex || 0,
            a = t.params.slidesPerGroup > 1 ? Math.floor(t.realIndex / t.params.slidesPerGroup) : t.realIndex) : void 0 !== t.snapIndex ? (a = t.snapIndex,
            r = t.previousSnapIndex) : (r = t.previousIndex || 0,
            a = t.activeIndex || 0),
            "bullets" === s.type && t.pagination.bullets && t.pagination.bullets.length > 0) {
                const i = t.pagination.bullets;
                let o, d, u;
                if (s.dynamicBullets && (n = E(i[0], t.isHorizontal() ? "width" : "height", !0),
                p.forEach((e => {
                    e.style[t.isHorizontal() ? "width" : "height"] = n * (s.dynamicMainBullets + 4) + "px"
                }
                )),
                s.dynamicMainBullets > 1 && void 0 !== r && (l += a - (r || 0),
                l > s.dynamicMainBullets - 1 ? l = s.dynamicMainBullets - 1 : l < 0 && (l = 0)),
                o = Math.max(a - l, 0),
                d = o + (Math.min(i.length, s.dynamicMainBullets) - 1),
                u = (d + o) / 2),
                i.forEach((e => {
                    const t = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((e => `${s.bulletActiveClass}${e}`))].map((e => "string" == typeof e && e.includes(" ") ? e.split(" ") : e)).flat();
                    e.classList.remove(...t)
                }
                )),
                p.length > 1)
                    i.forEach((e => {
                        const i = w(e);
                        i === a ? e.classList.add(...s.bulletActiveClass.split(" ")) : t.isElement && e.setAttribute("part", "bullet"),
                        s.dynamicBullets && (i >= o && i <= d && e.classList.add(...`${s.bulletActiveClass}-main`.split(" ")),
                        i === o && c(e, "prev"),
                        i === d && c(e, "next"))
                    }
                    ));
                else {
                    const e = i[a];
                    if (e && e.classList.add(...s.bulletActiveClass.split(" ")),
                    t.isElement && i.forEach(( (e, t) => {
                        e.setAttribute("part", t === a ? "bullet-active" : "bullet")
                    }
                    )),
                    s.dynamicBullets) {
                        const e = i[o]
                          , t = i[d];
                        for (let e = o; e <= d; e += 1)
                            i[e] && i[e].classList.add(...`${s.bulletActiveClass}-main`.split(" "));
                        c(e, "prev"),
                        c(t, "next")
                    }
                }
                if (s.dynamicBullets) {
                    const a = Math.min(i.length, s.dynamicMainBullets + 4)
                      , r = (n * a - n) / 2 - u * n
                      , l = e ? "right" : "left";
                    i.forEach((e => {
                        e.style[t.isHorizontal() ? l : "top"] = `${r}px`
                    }
                    ))
                }
            }
            p.forEach(( (e, r) => {
                if ("fraction" === s.type && (e.querySelectorAll(ee(s.currentClass)).forEach((e => {
                    e.textContent = s.formatFractionCurrent(a + 1)
                }
                )),
                e.querySelectorAll(ee(s.totalClass)).forEach((e => {
                    e.textContent = s.formatFractionTotal(m)
                }
                ))),
                "progressbar" === s.type) {
                    let i;
                    i = s.progressbarOpposite ? t.isHorizontal() ? "vertical" : "horizontal" : t.isHorizontal() ? "horizontal" : "vertical";
                    const r = (a + 1) / m;
                    let n = 1
                      , l = 1;
                    "horizontal" === i ? n = r : l = r,
                    e.querySelectorAll(ee(s.progressbarFillClass)).forEach((e => {
                        e.style.transform = `translate3d(0,0,0) scaleX(${n}) scaleY(${l})`,
                        e.style.transitionDuration = `${t.params.speed}ms`
                    }
                    ))
                }
                "custom" === s.type && s.renderCustom ? (e.innerHTML = s.renderCustom(t, a + 1, m),
                0 === r && i("paginationRender", e)) : (0 === r && i("paginationRender", e),
                i("paginationUpdate", e)),
                t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](s.lockClass)
            }
            ))
        }
        function m() {
            const e = t.params.pagination;
            if (d())
                return;
            const s = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length;
            let a = t.pagination.el;
            a = o(a);
            let r = "";
            if ("bullets" === e.type) {
                let a = t.params.loop ? Math.ceil(s / t.params.slidesPerGroup) : t.snapGrid.length;
                t.params.freeMode && t.params.freeMode.enabled && a > s && (a = s);
                for (let s = 0; s < a; s += 1)
                    e.renderBullet ? r += e.renderBullet.call(t, s, e.bulletClass) : r += `<${e.bulletElement} ${t.isElement ? 'part="bullet"' : ""} class="${e.bulletClass}"></${e.bulletElement}>`
            }
            "fraction" === e.type && (r = e.renderFraction ? e.renderFraction.call(t, e.currentClass, e.totalClass) : `<span class="${e.currentClass}"></span> / <span class="${e.totalClass}"></span>`),
            "progressbar" === e.type && (r = e.renderProgressbar ? e.renderProgressbar.call(t, e.progressbarFillClass) : `<span class="${e.progressbarFillClass}"></span>`),
            t.pagination.bullets = [],
            a.forEach((s => {
                "custom" !== e.type && (s.innerHTML = r || ""),
                "bullets" === e.type && t.pagination.bullets.push(...s.querySelectorAll(ee(e.bulletClass)))
            }
            )),
            "custom" !== e.type && i("paginationRender", a[0])
        }
        function h() {
            t.params.pagination = J(t, t.originalParams.pagination, t.params.pagination, {
                el: "swiper-pagination"
            });
            const e = t.params.pagination;
            if (!e.el)
                return;
            let s;
            "string" == typeof e.el && t.isElement && (s = t.el.querySelector(e.el)),
            s || "string" != typeof e.el || (s = [...document.querySelectorAll(e.el)]),
            s || (s = e.el),
            s && 0 !== s.length && (t.params.uniqueNavElements && "string" == typeof e.el && Array.isArray(s) && s.length > 1 && (s = [...t.el.querySelectorAll(e.el)],
            s.length > 1 && (s = s.filter((e => b(e, ".swiper")[0] === t.el))[0])),
            Array.isArray(s) && 1 === s.length && (s = s[0]),
            Object.assign(t.pagination, {
                el: s
            }),
            s = o(s),
            s.forEach((s => {
                "bullets" === e.type && e.clickable && s.classList.add(e.clickableClass),
                s.classList.add(e.modifierClass + e.type),
                s.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass),
                "bullets" === e.type && e.dynamicBullets && (s.classList.add(`${e.modifierClass}${e.type}-dynamic`),
                l = 0,
                e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)),
                "progressbar" === e.type && e.progressbarOpposite && s.classList.add(e.progressbarOppositeClass),
                e.clickable && s.addEventListener("click", p),
                t.enabled || s.classList.add(e.lockClass)
            }
            )))
        }
        function f() {
            const e = t.params.pagination;
            if (d())
                return;
            let s = t.pagination.el;
            s && (s = o(s),
            s.forEach((s => {
                s.classList.remove(e.hiddenClass),
                s.classList.remove(e.modifierClass + e.type),
                s.classList.remove(t.isHorizontal() ? e.horizontalClass : e.verticalClass),
                e.clickable && s.removeEventListener("click", p)
            }
            ))),
            t.pagination.bullets && t.pagination.bullets.forEach((t => t.classList.remove(...e.bulletActiveClass.split(" "))))
        }
        a("changeDirection", ( () => {
            if (!t.pagination || !t.pagination.el)
                return;
            const e = t.params.pagination;
            let {el: s} = t.pagination;
            s = o(s),
            s.forEach((s => {
                s.classList.remove(e.horizontalClass, e.verticalClass),
                s.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass)
            }
            ))
        }
        )),
        a("init", ( () => {
            !1 === t.params.pagination.enabled ? g() : (h(),
            m(),
            u())
        }
        )),
        a("activeIndexChange", ( () => {
            void 0 === t.snapIndex && u()
        }
        )),
        a("snapIndexChange", ( () => {
            u()
        }
        )),
        a("snapGridLengthChange", ( () => {
            m(),
            u()
        }
        )),
        a("destroy", ( () => {
            f()
        }
        )),
        a("enable disable", ( () => {
            let {el: e} = t.pagination;
            e && (e = o(e),
            e.forEach((e => e.classList[t.enabled ? "remove" : "add"](t.params.pagination.lockClass))))
        }
        )),
        a("lock unlock", ( () => {
            u()
        }
        )),
        a("click", ( (e, s) => {
            const a = s.target
              , r = o(t.pagination.el);
            if (t.params.pagination.el && t.params.pagination.hideOnClick && r && r.length > 0 && !a.classList.contains(t.params.pagination.bulletClass)) {
                if (t.navigation && (t.navigation.nextEl && a === t.navigation.nextEl || t.navigation.prevEl && a === t.navigation.prevEl))
                    return;
                const e = r[0].classList.contains(t.params.pagination.hiddenClass);
                i(!0 === e ? "paginationShow" : "paginationHide"),
                r.forEach((e => e.classList.toggle(t.params.pagination.hiddenClass)))
            }
        }
        ));
        const g = () => {
            t.el.classList.add(t.params.pagination.paginationDisabledClass);
            let {el: e} = t.pagination;
            e && (e = o(e),
            e.forEach((e => e.classList.add(t.params.pagination.paginationDisabledClass)))),
            f()
        }
        ;
        Object.assign(t.pagination, {
            enable: () => {
                t.el.classList.remove(t.params.pagination.paginationDisabledClass);
                let {el: e} = t.pagination;
                e && (e = o(e),
                e.forEach((e => e.classList.remove(t.params.pagination.paginationDisabledClass)))),
                h(),
                m(),
                u()
            }
            ,
            disable: g,
            render: m,
            update: u,
            init: h,
            destroy: f
        })
    }
    , function(e) {
        let {swiper: t, extendParams: s, on: i, emit: r} = e;
        const l = a();
        let o, d, c, p, u = !1, m = null, h = null;
        function v() {
            if (!t.params.scrollbar.el || !t.scrollbar.el)
                return;
            const {scrollbar: e, rtlTranslate: s} = t
              , {dragEl: a, el: i} = e
              , r = t.params.scrollbar
              , n = t.params.loop ? t.progressLoop : t.progress;
            let l = d
              , o = (c - d) * n;
            s ? (o = -o,
            o > 0 ? (l = d - o,
            o = 0) : -o + d > c && (l = c + o)) : o < 0 ? (l = d + o,
            o = 0) : o + d > c && (l = c - o),
            t.isHorizontal() ? (a.style.transform = `translate3d(${o}px, 0, 0)`,
            a.style.width = `${l}px`) : (a.style.transform = `translate3d(0px, ${o}px, 0)`,
            a.style.height = `${l}px`),
            r.hide && (clearTimeout(m),
            i.style.opacity = 1,
            m = setTimeout(( () => {
                i.style.opacity = 0,
                i.style.transitionDuration = "400ms"
            }
            ), 1e3))
        }
        function w() {
            if (!t.params.scrollbar.el || !t.scrollbar.el)
                return;
            const {scrollbar: e} = t
              , {dragEl: s, el: a} = e;
            s.style.width = "",
            s.style.height = "",
            c = t.isHorizontal() ? a.offsetWidth : a.offsetHeight,
            p = t.size / (t.virtualSize + t.params.slidesOffsetBefore - (t.params.centeredSlides ? t.snapGrid[0] : 0)),
            d = "auto" === t.params.scrollbar.dragSize ? c * p : parseInt(t.params.scrollbar.dragSize, 10),
            t.isHorizontal() ? s.style.width = `${d}px` : s.style.height = `${d}px`,
            a.style.display = p >= 1 ? "none" : "",
            t.params.scrollbar.hide && (a.style.opacity = 0),
            t.params.watchOverflow && t.enabled && e.el.classList[t.isLocked ? "add" : "remove"](t.params.scrollbar.lockClass)
        }
        
        function M() {
            const {scrollbar: e, el: s} = t;
            t.params.scrollbar = J(t, t.originalParams.scrollbar, t.params.scrollbar, {
                el: "swiper-scrollbar"
            });
            const a = t.params.scrollbar;
            if (!a.el)
                return;
            let i, r;
            "string" == typeof a.el && t.isElement && (i = t.el.querySelector(a.el)),
            i || "string" != typeof a.el ? i || (i = a.el) : i = l.querySelectorAll(a.el),
            t.params.uniqueNavElements && "string" == typeof a.el && i.length > 1 && 1 === s.querySelectorAll(a.el).length && (i = s.querySelector(a.el)),
            i.length > 0 && (i = i[0]),
            i.classList.add(t.isHorizontal() ? a.horizontalClass : a.verticalClass),
            i && (r = i.querySelector(`.${t.params.scrollbar.dragClass}`),
            r || (r = f("div", t.params.scrollbar.dragClass),
            i.append(r))),
            Object.assign(e, {
                el: i,
                dragEl: r
            }),
            a.draggable && t.params.scrollbar.el && t.scrollbar.el && T("on"),
            i && i.classList[t.enabled ? "remove" : "add"](t.params.scrollbar.lockClass)
        }
        function C() {
            const e = t.params.scrollbar
              , s = t.scrollbar.el;
            s && s.classList.remove(t.isHorizontal() ? e.horizontalClass : e.verticalClass),
            t.params.scrollbar.el && t.scrollbar.el && T("off")
        }
        s({
            scrollbar: {
                el: null,
                dragSize: "auto",
                hide: !1,
                draggable: !1,
                snapOnRelease: !0,
                lockClass: "swiper-scrollbar-lock",
                dragClass: "swiper-scrollbar-drag",
                scrollbarDisabledClass: "swiper-scrollbar-disabled",
                horizontalClass: "swiper-scrollbar-horizontal",
                verticalClass: "swiper-scrollbar-vertical"
            }
        }),
        t.scrollbar = {
            el: null,
            dragEl: null
        },
        i("init", ( () => {
            !1 === t.params.scrollbar.enabled ? P() : (M(),
            w(),
            v())
        }
        )),
        i("update resize observerUpdate lock unlock", ( () => {
            w()
        }
        )),   
    
            disable: P,
            updateSize: w,
            setTranslate: v,
            init: M,
            destroy: C
        
    }
    , function(e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({
            parallax: {
                enabled: !1
            }
        });
       
        
        a("beforeInit", ( () => {
            t.params.parallax.enabled && (t.params.watchSlidesProgress = !0,
            t.originalParams.watchSlidesProgress = !0)
        }
        )),
        a("init", ( () => {
            t.params.parallax.enabled && r()
        }
        )),
        a("setTranslate", ( () => {
            t.params.parallax.enabled && r()
        }
        )),
        a("setTransition", ( (e, s) => {
            t.params.parallax.enabled && function(e) {
                void 0 === e && (e = t.params.speed);
                const {el: s} = t;
                s.querySelectorAll("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").forEach((t => {
                    let s = parseInt(t.getAttribute("data-swiper-parallax-duration"), 10) || e;
                    0 === e && (s = 0),
                    t.style.transitionDuration = `${s}ms`
                }
                ))
            }(s)
        }
        ))
    }
    , function(e) {
        let {swiper: t, extendParams: s, on: a, emit: i} = e;
        const n = r();
        s({
            zoom: {
                enabled: !1,
                maxRatio: 3,
                minRatio: 1,
                toggle: !0,
                containerClass: "swiper-zoom-container",
                zoomedSlideClass: "swiper-slide-zoomed"
            }
        }),
        t.zoom = {
            enabled: !1
        };
        let l, d, c = 1, p = !1;
        const u = []
          , m = {
            originX: 0,
            originY: 0,
            slideEl: void 0,
            slideWidth: void 0,
            slideHeight: void 0,
            imageEl: void 0,
            imageWrapEl: void 0,
            maxRatio: 3
        }
          , f = {
            isTouched: void 0,
            isMoved: void 0,
            currentX: void 0,
            currentY: void 0,
            minX: void 0,
            minY: void 0,
            maxX: void 0,
            maxY: void 0,
            width: void 0,
            height: void 0,
            startX: void 0,
            startY: void 0,
            touchesStart: {},
            touchesCurrent: {}
        }
          , v = {
            x: void 0,
            y: void 0,
            prevPositionX: void 0,
            prevPositionY: void 0,
            prevTime: void 0
        };
        let w = 1;
       
        
       
        a("init", ( () => {
            t.params.zoom.enabled && $()
        }
        )),
        a("destroy", ( () => {
            I()
        }
        )),
      
        
        a("doubleTap", ( (e, s) => {
            !t.animating && t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && z(s)
        }
        )),
        a("transitionEnd", ( () => {
            t.zoom.enabled && t.params.zoom.enabled && C()
        }
        )),
        a("slideChange", ( () => {
            t.zoom.enabled && t.params.zoom.enabled && t.params.cssMode && C()
        }
        )),
        Object.assign(t.zoom, {
            enable: $,
            disable: I,
            in: P,
            out: L,
            toggle: z
        })
    }
    , function(e) {
        let {swiper: t, extendParams: s, on: a} = e;
       
        function r() {
            t.controller.control && t.controller.spline && (t.controller.spline = void 0,
            delete t.controller.spline)
        }
        s({
            controller: {
                control: void 0,
                inverse: !1,
                by: "slide"
            }
        }),
        t.controller = {
            control: void 0
        },
        a("beforeInit", ( () => {
            if ("undefined" != typeof window && ("string" == typeof t.params.controller.control || t.params.controller.control instanceof HTMLElement)) {
                const e = document.querySelector(t.params.controller.control);
                if (e && e.swiper)
                    t.controller.control = e.swiper;
                else if (e) {
                    const s = a => {
                        t.controller.control = a.detail[0],
                        t.update(),
                        e.removeEventListener("init", s)
                    }
                    ;
                    e.addEventListener("init", s)
                }
            } else
                t.controller.control = t.params.controller.control
        }
        )),
        a("update", ( () => {
            r()
        }
        )),
        a("resize", ( () => {
            r()
        }
        )),
        a("observerUpdate", ( () => {
            r()
        }
        )),
        a("setTranslate", ( (e, s, a) => {
            t.controller.control && !t.controller.control.destroyed && t.controller.setTranslate(s, a)
        }
        )),
        a("setTransition", ( (e, s, a) => {
            t.controller.control && !t.controller.control.destroyed && t.controller.setTransition(s, a)
        }
        )),
        
     function(e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({
            a11y: {
                enabled: !0,
                notificationClass: "swiper-notification",
                prevSlideMessage: "Previous slide",
                nextSlideMessage: "Next slide",
                firstSlideMessage: "This is the first slide",
                lastSlideMessage: "This is the last slide",
                paginationBulletMessage: "Go to slide {{index}}",
                slideLabelMessage: "{{index}} / {{slidesLength}}",
                containerMessage: null,
                containerRoleDescriptionMessage: null,
                itemRoleDescriptionMessage: null,
                slideRole: "group",
                id: null
            }
        }),
        t.a11y = {
            clicked: !1
        };
        
        const n = e => (Array.isArray(e) || (e = [e].filter((e => !!e))),
        e);
        function l(e) {
            (e = n(e)).forEach((e => {
                e.setAttribute("tabIndex", "0")
            }
            ))
        }
       
        function d(e, t) {
            (e = n(e)).forEach((e => {
                e.setAttribute("role", t)
            }
            ))
        }
        function p(e, t) {
            (e = n(e)).forEach((e => {
                e.setAttribute("aria-label", t)
            }
            ))
        }
        function g() {
            return t.pagination && t.pagination.bullets && t.pagination.bullets.length
        }
        function v() {
            return g() && t.params.pagination.clickable
        }
        S = () => {
            const e = t.params.a11y;
            e.itemRoleDescriptionMessage && c(t.slides, e.itemRoleDescriptionMessage),
            e.slideRole && d(t.slides, e.slideRole);
            const s = t.slides.length;
            e.slideLabelMessage && t.slides.forEach(( (a, i) => {
                const r = t.params.loop ? parseInt(a.getAttribute("data-swiper-slide-index"), 10) : i;
                p(a, e.slideLabelMessage.replace(/\{\{index\}\}/, r + 1).replace(/\{\{slidesLength\}\}/, s))
            }
            ))
        }
          , T = () => {
            const e = t.params.a11y;
            t.el.append(i);
            const s = t.el;
            e.containerRoleDescriptionMessage && c(s, e.containerRoleDescriptionMessage),
            e.containerMessage && p(s, e.containerMessage);
            const a = t.wrapperEl
              , r = e.id || a.getAttribute("id") || `swiper-wrapper-${l = 16,
            void 0 === l && (l = 16),
            "x".repeat(l).replace(/x/g, ( () => Math.round(16 * Math.random()).toString(16)))}`;
            var l;
            const o = t.params.autoplay && t.params.autoplay.enabled ? "off" : "polite";
            var d;
            d = r,
            n(a).forEach((e => {
                e.setAttribute("id", d)
            }
            )),
            function(e, t) {
                (e = n(e)).forEach((e => {
                    e.setAttribute("aria-live", t)
                }
                ))
            }(a, o),
            S();
            let {nextEl: u, prevEl: m} = t.navigation ? t.navigation : {};
            if (u = n(u),
            m = n(m),
            u && u.forEach((t => b(t, r, e.nextSlideMessage))),
            m && m.forEach((t => b(t, r, e.prevSlideMessage))),
            v()) {
                (Array.isArray(t.pagination.el) ? t.pagination.el : [t.pagination.el]).forEach((e => {
                    e.addEventListener("keydown", h)
                }
                ))
            }
            t.el.addEventListener("focus", x, !0),
            t.el.addEventListener("pointerdown", y, !0),
            t.el.addEventListener("pointerup", E, !0)
        }
        ;
        a("beforeInit", ( () => {
            i = f("span", t.params.a11y.notificationClass),
            i.setAttribute("aria-live", "assertive"),
            i.setAttribute("aria-atomic", "true")
        }
        )),
        a("afterInit", ( () => {
            t.params.a11y.enabled && T()
        }
        )),
        a("slidesLengthChange snapGridLengthChange slidesGridLengthChange", ( () => {
            t.params.a11y.enabled && S()
        }
        )),
        a("fromEdge toEdge afterInit lock unlock", ( () => {
            t.params.a11y.enabled && function() {
                if (t.params.loop || t.params.rewind || !t.navigation)
                    return;
                const {nextEl: e, prevEl: s} = t.navigation;
                s && (t.isBeginning ? (u(s),
                o(s)) : (m(s),
                l(s))),
                e && (t.isEnd ? (u(e),
                o(e)) : (m(e),
                l(e)))
            }()
        }
        )),
        a("paginationUpdate", ( () => {
            t.params.a11y.enabled && function() {
                const e = t.params.a11y;
                g() && t.pagination.bullets.forEach((s => {
                    t.params.pagination.clickable && (l(s),
                    t.params.pagination.renderBullet || (d(s, "button"),
                    p(s, e.paginationBulletMessage.replace(/\{\{index\}\}/, w(s) + 1)))),
                    s.matches(ee(t.params.pagination.bulletActiveClass)) ? s.setAttribute("aria-current", "true") : s.removeAttribute("aria-current")
                }
                ))
            }()
        }
        ))
    , function(e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({
            history: {
                enabled: !1,
                root: "",
                replaceState: !1,
                key: "slides",
                keepQuery: !1
            }
        });
        let i = !1
          , n = {};
        const l = e => e.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, "")
          ,
          
          , p = () => {
            n = o(t.params.url),
            c(t.params.speed, n.value, !1)
        }
        ;
        
        a("destroy", ( () => {
            t.params.history.enabled && ( () => {
                const e = r();
                t.params.history.replaceState || e.removeEventListener("popstate", p)
            }
            )()
        }
        )),
        a("transitionEnd _freeModeNoMomentumRelease", ( () => {
            i && d(t.params.history.key, t.activeIndex)
        }
        )),
        a("slideChange", ( () => {
            i && t.params.cssMode && d(t.params.history.key, t.activeIndex)
        }
        ))
    }
    , function(e) {
        let {swiper: t, extendParams: s, emit: i, on: n} = e
          , l = !1;
        const o = a()
          , d = r();
        s({
            hashNavigation: {
                enabled: !1,
                replaceState: !1,
                watchState: !1,
               
            }
        });
        
     
        n("destroy", ( () => {
            t.params.hashNavigation.enabled && t.params.hashNavigation.watchState && d.removeEventListener("hashchange", c)
        }
        )),
        n("transitionEnd _freeModeNoMomentumRelease", ( () => {
            l && p()
        }
        )),
        n("slideChange", ( () => {
            l && t.params.cssMode && p()
        }
        ))
    }
    , function(e) {
        let t, s, {swiper: i, extendParams: r, on: n, emit: l, params: o} = e;
        i.autoplay = {
            running: !1,
            paused: !1,
            timeLeft: 0
        },
        r({
            autoplay: {
                enabled: !1,
                delay: 3e3,
                waitForTransition: !0,
                disableOnInteraction: !0,
                stopOnLastSlide: !1,
                reverseDirection: !1,
                pauseOnMouseEnter: !1
            }
        });
        let d, c, p, u, m, h, f, g = o && o.autoplay ? o.autoplay.delay : 3e3, v = o && o.autoplay ? o.autoplay.delay : 3e3, w = (new Date).getTime;
        
        const y = () => {
            if (i.destroyed || !i.autoplay.running)
                return;
            i.autoplay.paused ? c = !0 : c && (v = d,
            c = !1);
            const e = i.autoplay.paused ? d : w + v - (new Date).getTime();
            i.autoplay.timeLeft = e,
            l("autoplayTimeLeft", e, e / g),
            s = requestAnimationFrame(( () => {
                y()
            }
            ))
        }
          , E = e => {
            if (i.destroyed || !i.autoplay.running)
                return;
            cancelAnimationFrame(s),
            y();
            let a = void 0 === e ? i.params.autoplay.delay : e;
            g = i.params.autoplay.delay,
            v = i.params.autoplay.delay;
            const r = ( () => {
                let e;
                if (e = i.virtual && i.params.virtual.enabled ? i.slides.filter((e => e.classList.contains("swiper-slide-active")))[0] : i.slides[i.activeIndex],
                !e)
                    return;
                return parseInt(e.getAttribute("data-swiper-autoplay"), 10)
            }
            )();
            !Number.isNaN(r) && r > 0 && void 0 === e && (a = r,
            g = r,
            v = r),
            d = a;
            const n = i.params.speed
              , 
            ;
            return a > 0 ? (clearTimeout(t),
            t = setTimeout(( () => {
                o()
            }
            ), a)) : requestAnimationFrame(( () => {
                o()
            }
            )),
            a
        }
          , x = () => {
            i.autoplay.running = !0,
            E(),
            l("autoplayStart")
        }
          , S = () => {
            i.autoplay.running = !1,
            clearTimeout(t),
            cancelAnimationFrame(s),
            l("autoplayStop")
        }

          , C = () => {
            if (i.destroyed || !i.autoplay.running)
                return;
            const e = a();
            "hidden" === e.visibilityState && (f = !0,
            T(!0)),
            "visible" === e.visibilityState && M()
        }
          , P = e => {
            "mouse" === e.pointerType && (f = !0,
            T(!0))
        }
          , L = e => {
            "mouse" === e.pointerType && i.autoplay.paused && M()
        }
        ;
        n("init", ( () => {
            i.params.autoplay.enabled && (i.params.autoplay.pauseOnMouseEnter && (i.el.addEventListener("pointerenter", P),
            i.el.addEventListener("pointerleave", L)),
            a().addEventListener("visibilitychange", C),
            w = (new Date).getTime(),
            x())
        }
        )),
        n("destroy", ( () => {
            i.el.removeEventListener("pointerenter", P),
            i.el.removeEventListener("pointerleave", L),
            a().removeEventListener("visibilitychange", C),
            i.autoplay.running && S()
        }
        )),
        n("beforeTransitionStart", ( (e, t, s) => {
            !i.destroyed && i.autoplay.running && (s || !i.params.autoplay.disableOnInteraction ? T(!0, !0) : S())
        }
        )),
        n("sliderFirstMove", ( () => {
            !i.destroyed && i.autoplay.running && (i.params.autoplay.disableOnInteraction ? S() : (p = !0,
            u = !1,
            f = !1,
            m = setTimeout(( () => {
                f = !0,
                u = !0,
                T(!0)
            }
            ), 200)))
        }
        )),
        n("touchEnd", ( () => {
            if (!i.destroyed && i.autoplay.running && p) {
                if (clearTimeout(m),
                clearTimeout(t),
                i.params.autoplay.disableOnInteraction)
                    return u = !1,
                    void (p = !1);
                u && i.params.cssMode && M(),
                u = !1,
                p = !1
            }
        }
        )),
        n("slideChange", ( () => {
            !i.destroyed && i.autoplay.running && (h = !0)
        }
        )),
        Object.assign(i.autoplay, {
            start: x,
            stop: S,
            pause: T,
            resume: M
        })
    }
    , function(e) {
        let {swiper: t, extendParams: s, on: i} = e;
        s({
            thumbs: {
                swiper: null,
                multipleActiveThumbs: !0,
                autoScrollOffset: 0,
                slideThumbActiveClass: "swiper-slide-thumb-active",
                thumbsContainerClass: "swiper-thumbs"
            }
        });
        let r = !1
          , n = !1;
        
       
        function c(e) {
            const s = t.thumbs.swiper;
            if (!s || s.destroyed)
                return;
            const a = "auto" === s.params.slidesPerView ? s.slidesPerViewDynamic() : s.params.slidesPerView;
            let i = 1;
            const r = t.params.thumbs.slideThumbActiveClass;
            if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (i = t.params.slidesPerView),
            t.params.thumbs.multipleActiveThumbs || (i = 1),
            i = Math.floor(i),
            s.slides.forEach((e => e.classList.remove(r))),
            s.params.loop || s.params.virtual && s.params.virtual.enabled)
                for (let e = 0; e < i; e += 1)
                    h(s.slidesEl, `[data-swiper-slide-index="${t.realIndex + e}"]`).forEach((e => {
                        e.classList.add(r)
                    }
                    ));
            else
                for (let e = 0; e < i; e += 1)
                    s.slides[t.realIndex + e] && s.slides[t.realIndex + e].classList.add(r);
            const n = t.params.thumbs.autoScrollOffset
              , l = n && !s.params.loop;
            if (t.realIndex !== s.realIndex || l) {
                const i = s.activeIndex;
                let r, o;
                if (s.params.loop) {
                    const e = s.slides.filter((e => e.getAttribute("data-swiper-slide-index") === `${t.realIndex}`))[0];
                    r = s.slides.indexOf(e),
                    o = t.activeIndex > t.previousIndex ? "next" : "prev"
                } else
                    r = t.realIndex,
                    o = r > t.previousIndex ? "next" : "prev";
                l && (r += "next" === o ? n : -1 * n),
                s.visibleSlidesIndexes && s.visibleSlidesIndexes.indexOf(r) < 0 && (s.params.centeredSlides ? r = r > i ? r - Math.floor(a / 2) + 1 : r + Math.floor(a / 2) - 1 : r > i && s.params.slidesPerGroup,
                s.slideTo(r, e ? 0 : void 0))
            }
        }
        t.thumbs = {
            swiper: null
        },
        i("beforeInit", ( () => {
            const {thumbs: e} = t.params;
            if (e && e.swiper)
                if ("string" == typeof e.swiper || e.swiper instanceof HTMLElement) {
                    const s = a()
                      , 
                      , r = () => {
                        if (t.destroyed)
                            return;
                        i() || requestAnimationFrame(r)
                    }
                    ;
                    requestAnimationFrame(r)
                } else
                    o(),
                    c(!0)
        }
        )),
        i("slideChange update resize observerUpdate", ( () => {
            c()
        }
        )),
        i("setTransition", ( (e, s) => {
            const a = t.thumbs.swiper;
            a && !a.destroyed && a.setTransition(s)
        }
        )),
        i("beforeDestroy", ( () => {
            const e = t.thumbs.swiper;
            e && !e.destroyed && n && e.destroy()
        }
        )),
        Object.assign(t.thumbs, {
            init: o,
            update: c
        })
    }
    , function(e) {
        let {swiper: t, extendParams: s, emit: a, once: i} = e;
        s({
            freeMode: {
                enabled: !1,
                momentum: !0,
                momentumRatio: 1,
                momentumBounce: !0,
                momentumBounceRatio: 1,
                momentumVelocityRatio: 1,
                sticky: !1,
                minimumVelocity: .02
            }
        }),
        
                
           
    function(e) {
        let t, s, a, {swiper: i, extendParams: r} = e;
        r({
            grid: {
                rows: 1,
                fill: "column"
            }
        });
       
              
            
        
    }
    , function(e) {
        let {swiper: t} = e;
        Object.assign(t, {
            appendSlide: te.bind(t),
            prependSlide: se.bind(t),
            addSlide: ae.bind(t),
            removeSlide: ie.bind(t),
            removeAllSlides: re.bind(t)
        })
    }
    , function(e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({
            fadeEffect: {
                crossFade: !1
            }
        }),
        ne({
            effect: "fade",
            swiper: t,
            on: a,
        
          
            
        })
    }
    , function(e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({
            cubeEffect: {
                slideShadows: !0,
                shadow: !0,
                shadowOffset: 20,
                shadowScale: .94
            }
        });
       
        ne({
            effect: "cube",
            swiper: t,
            on: a,
         
           
            getEffectParams: () => t.params.cubeEffect,
            perspective: () => !0,
           
        })
    }
    , function(e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({
            flipEffect: {
                slideShadows: !0,
                limitRotation: !0
            }
        });
       
        ne({
            effect: "flip",
            swiper: t,
            on: a,
            setTranslate: () => {
                const {slides: e, rtlTranslate: s} = t
                  , a = t.params.flipEffect;
                for (let r = 0; r < e.length; r += 1) {
                    const n = e[r];
                    let l = n.progress;
                    t.params.flipEffect.limitRotation && (l = Math.max(Math.min(n.progress, 1), -1));
                    const o = n.swiperSlideOffset;
                    let d = -180 * l
                      , c = 0
                      , p = t.params.cssMode ? -o - t.translate : -o
                      , u = 0;
                    t.isHorizontal() ? s && (d = -d) : (u = p,
                    p = 0,
                    c = -d,
                    d = 0),
                    n.style.zIndex = -Math.abs(Math.round(l)) + e.length,
                    a.slideShadows && i(n, l);
                    const m = `translate3d(${p}px, ${u}px, 0px) rotateX(${c}deg) rotateY(${d}deg)`;
                    le(0, n).style.transform = m
                }
            }
            ,
            setTransition: e => {
                const s = t.slides.map((e => m(e)));
                s.forEach((t => {
                    t.style.transitionDuration = `${e}ms`,
                    t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((t => {
                        t.style.transitionDuration = `${e}ms`
                    }
                    ))
                }
                )),
                oe({
                    swiper: t,
                    duration: e,
                    transformElements: s
                })
            }
            ,
           
            getEffectParams: () => t.params.flipEffect,
            perspective: () => !0,
           
        })
    }
    , function(e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({
            coverflowEffect: {
                rotate: 50,
                stretch: 0,
                depth: 100,
                scale: 1,
                modifier: 1,
                slideShadows: !0
            }
        }),
        ne({
            effect: "coverflow",
            swiper: t,
            on: a,
           
            setTransition: e => {
                t.slides.map((e => m(e))).forEach((t => {
                    t.style.transitionDuration = `${e}ms`,
                    t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((t => {
                        t.style.transitionDuration = `${e}ms`
                    }
                    ))
                }
                ))
            }
            ,
            perspective: () => !0,
            overwriteParams: () => ({
                watchSlidesProgress: !0
            })
        })
    }
    , function(e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({
            creativeEffect: {
                limitProgress: 1,
                shadowPerProgress: !1,
                progressMultiplier: 1,
                perspective: !0,
                prev: {
                    translate: [0, 0, 0],
                    rotate: [0, 0, 0],
                    opacity: 1,
                    scale: 1
                },
                next: {
                    translate: [0, 0, 0],
                    rotate: [0, 0, 0],
                    opacity: 1,
                    scale: 1
                }
            }
        });
        const i = e => "string" == typeof e ? e : `${e}px`;
        ne({
            effect: "creative",
            swiper: t,
            on: a,
          
            setTransition: e => {
                const s = t.slides.map((e => m(e)));
                s.forEach((t => {
                    t.style.transitionDuration = `${e}ms`,
                    t.querySelectorAll(".swiper-slide-shadow").forEach((t => {
                        t.style.transitionDuration = `${e}ms`
                    }
                    ))
                }
                )),
                oe({
                    swiper: t,
                    duration: e,
                    transformElements: s,
                    allSlides: !0
                })
            }
            ,
            perspective: () => t.params.creativeEffect.perspective,
            overwriteParams: () => ({
                watchSlidesProgress: !0,
                virtualTranslate: !t.params.cssMode
            })
        })
    }
    , function(e) {
        let {swiper: t, extendParams: s, on: a} = e;
        s({
            cardsEffect: {
                slideShadows: !0,
                rotate: !0,
                perSlideRotate: 2,
                perSlideOffset: 8
            }
        }),
        ne({
            effect: "cards",
            swiper: t,
            on: a,
            setTranslate: () => {
                const {slides: e, activeIndex: s, rtlTranslate: a} = t
                  , i = t.params.cardsEffect
                  , {startTranslate: r, isTouched: n} = t.touchEventsData
                  , l = a ? -t.translate : t.translate;
                for (let o = 0; o < e.length; o += 1) {
                    const d = e[o]
                      , c = d.progress
                      , p = Math.min(Math.max(c, -4), 4);
                    let u = d.swiperSlideOffset;
                    t.params.centeredSlides && !t.params.cssMode && (t.wrapperEl.style.transform = `translateX(${t.minTranslate()}px)`),
                    t.params.centeredSlides && t.params.cssMode && (u -= e[0].swiperSlideOffset);
                    let m = t.params.cssMode ? -u - t.translate : -u
                      , h = 0;
                    const f = -100 * Math.abs(p);
                    let g = 1
                      , v = -i.perSlideRotate * p
                      , w = i.perSlideOffset - .75 * Math.abs(p);
                    const b = t.virtual && t.params.virtual.enabled ? t.virtual.from + o : o
                      , y = (b === s || b === s - 1) && p > 0 && p < 1 && (n || t.params.cssMode) && l < r
                      , E = (b === s || b === s + 1) && p < 0 && p > -1 && (n || t.params.cssMode) && l > r;
                    if (y || E) {
                        const e = (1 - Math.abs((Math.abs(p) - .5) / .5)) ** .5;
                        v += -28 * p * e,
                        g += -.5 * e,
                        w += 96 * e,
                        h = -25 * e * Math.abs(p) + "%"
                    }
                    if (m = p < 0 ? `calc(${m}px ${a ? "-" : "+"} (${w * Math.abs(p)}%))` : p > 0 ? `calc(${m}px ${a ? "-" : "+"} (-${w * Math.abs(p)}%))` : `${m}px`,
                    !t.isHorizontal()) {
                        const e = h;
                        h = m,
                        m = e
                    }
                    const x = p < 0 ? "" + (1 + (1 - g) * p) : "" + (1 - (1 - g) * p)
                      , S = `\n        translate3d(${m}, ${h}, ${f}px)\n        rotateZ(${i.rotate ? a ? -v : v : 0}deg)\n        scale(${x})\n      `;
                    if (i.slideShadows) {
                        let e = d.querySelector(".swiper-slide-shadow");
                        e || (e = de("cards", d)),
                        e && (e.style.opacity = Math.min(Math.max((Math.abs(p) - .5) / .5, 0), 1))
                    }
                    d.style.zIndex = -Math.abs(Math.round(c)) + e.length;
                    le(0, d).style.transform = S
                }
            }
            ,
            setTransition: e => {
                const s = t.slides.map((e => m(e)));
                s.forEach((t => {
                    t.style.transitionDuration = `${e}ms`,
                    t.querySelectorAll(".swiper-slide-shadow").forEach((t => {
                        t.style.transitionDuration = `${e}ms`
                    }
                    ))
                }
                )),
                oe({
                    swiper: t,
                    duration: e,
                    transformElements: s
                })
            }
            ,
            perspective: () => !0,
            overwriteParams: () => ({
                watchSlidesProgress: !0,
                virtualTranslate: !t.params.cssMode
            })
        })
    }
    ];
    return Q.use(ce),
    Q
}();
//# sourceMappingURL=swiper-bundle.js.map
